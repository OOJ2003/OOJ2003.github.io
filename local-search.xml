<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Rust并发入坑记录</title>
    <link href="/2023/09/17/%E6%8A%80%E6%9C%AF/Rust%E5%B9%B6%E5%8F%91%E5%85%A5%E5%9D%91%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/09/17/%E6%8A%80%E6%9C%AF/Rust%E5%B9%B6%E5%8F%91%E5%85%A5%E5%9D%91%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>## 开始之前的碎碎念</p><p>就像之前说过的，终于得用 <code>rust</code> 玩点并发了。<code>rust</code> 的并发还是很有意思的，和完全依赖系统函数调用的 <code>c</code> 不太一样， <code>rust</code> 提供了一定的上层抽象，同时也尽可能地通过内置的静态检查去规避可能出现的线程安全问题。</p><p>由于 <code>rust</code> 是相当偏底层的语言之一，和自带 <code>runtime</code> 的种种语言相比，实现并发需要考虑的细节就更多了。</p><p>当然我们不会去写传统的多线程应用，在应用程序里手动的创建多个线程可太蠢了，都已经2023年了，就当然要用协程来写并发！</p><p>和 <code>cpp</code> 的情况类似，<code>rust</code> 的协程也是通过用户态线程（虚拟线程/协程）+ 协程调度器实现的。</p><p>听起来很抽象，但是根据我的理解，这玩意儿有点像是 <code>v-dom</code>。</p><p>内核线程的创建和切换等操作都相当的花时间，但是内核态的线程是由操作系统调度且能直接控制硬件资源的。而用户态线程则恰恰相反，它的管理工作交由用户程序等上层的 <code>runtime</code> 实现，所以用户态线程可以同时创建几千上万个而不会阻塞当前线程的工作。</p><p>为了使得协程实际执行各项任务，在创建协程之外还需要一个协程调度器将其绑定到真实的内核线程之上，就像 <code>golang</code> 的 <code>goroutine</code> 一样！</p><p>比较蛋疼的是 <code>rust</code> 的标准库里压根就没有协程调度器的存在，所以为了愉快的开始写并发程序，还需要一个第三方运行时的支持。</p><p>本次的记录中使用的算是 <code>rust</code> 社区生态中相当主流的异步运行时之一——<code>Tokio</code>。由于大多数异步库或者应用都直接或间接的依赖于它，所以某种意义上来说，<code>Tokio</code>已经成为了当前 <code>rust</code> 异步生态的事实标准。</p><h2 id="协程版本的你好世界">协程版本的你好世界</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> mini_redis::&#123;client, <span class="hljs-type">Result</span>&#125;;<br><br><span class="hljs-meta">#[tokio::main]</span><br><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Open a connection to the mini-redis address.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">client</span> = client::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-comment">// Set the key &quot;hello&quot; with value &quot;world&quot;</span><br>    client.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-comment">// Get key &quot;hello&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = client.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;hello&quot;</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got value from the server; result=&#123;:?&#125;&quot;</span>, result);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码挺简单的，唯一特别的地方可能就是 <code>await</code> 关键字的位置，<code>main</code> 函数上的宏，以及语句末尾的 <code>?</code> 。</p><p>主要是我主力还是写前端居多，所以 <code>await</code> 后置感觉就怪怪的，<code>rust</code> 里面这样写就有的更接近于 <code>Promise</code> 的 <code>then</code> 调用。</p><p><code>?</code> 则是 <code>rust</code> 里针对函数返回 <code>Option&lt;T&gt;</code> 或者 <code>Result&lt;T&gt;</code> 的一个语法糖，具体可以参考<a href="https://github.com/rust-lang/book/blob/main/src/ch09-02-recoverable-errors-with-result.md">文档</a></p><p>而这个奇特的宏 <code>#[tokio::main]</code> 就比较有门道了。下面是 <code>cargo expand</code> 展开的代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![feature(prelude_import)]</span><br><span class="hljs-meta">#[prelude_import]</span><br><span class="hljs-keyword">use</span> std::prelude::rust_2021::*;<br><span class="hljs-meta">#[macro_use]</span><br><span class="hljs-keyword">extern</span> <span class="hljs-keyword">crate</span> std;<br><span class="hljs-keyword">use</span> mini_redis::&#123;client, <span class="hljs-type">Result</span>&#125;;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">body</span> = <span class="hljs-keyword">async</span> &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">client</span> = client::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>).<span class="hljs-keyword">await</span>?;<br>        client.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()).<span class="hljs-keyword">await</span>?;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = client.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;hello&quot;</span>).<span class="hljs-keyword">await</span>?;<br>        &#123;<br>            ::std::io::_print(<br>                <span class="hljs-built_in">format_args!</span>(<span class="hljs-string">&quot;got value from the server; result=&#123;0:?&#125;\n&quot;</span>, result),<br>            );<br>        &#125;;<br>        <span class="hljs-title function_ invoke__">Ok</span>(())<br>    &#125;;<br>    <span class="hljs-meta">#[allow(clippy::expect_used, clippy::diverging_sub_expression)]</span><br>    &#123;<br>        <span class="hljs-keyword">return</span> tokio::runtime::Builder::<span class="hljs-title function_ invoke__">new_multi_thread</span>()<br>            .<span class="hljs-title function_ invoke__">enable_all</span>()<br>            .<span class="hljs-title function_ invoke__">build</span>()<br>            .<span class="hljs-title function_ invoke__">expect</span>(<span class="hljs-string">&quot;Failed building the Runtime&quot;</span>)<br>            .<span class="hljs-title function_ invoke__">block_on</span>(body);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>原先的 <code>main</code> 函数的内容被转移到了 <code>body</code> 这个闭包中，并且通过一个奇特 <code>block_on</code> 方法调用。</p><p>尽管这其中有很多从没见过的方法调用，但是实际上我们只需要关心<code>new_multi_thread</code> 这个静态函数以及上文提到的<code>block_on</code> 。</p><p>下面是其函数签名</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new_multi_thread</span>() <span class="hljs-punctuation">-&gt;</span> Builder<br></code></pre></td></tr></table></figure><p>额，又冒出一个新类型。。。</p><p>根据<a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html#implementations">文档</a>所言，这个函数会返回一个使用多线程调度的<code>builder</code>。</p><p>而 <a href="https://docs.rs/tokio/latest/tokio/runtime/struct.Builder.html"><code>builder</code></a> 则是一个用于自定义 <code>tokio</code> 运行时的构造函数，<code>enable_all</code> 是一个链式调用的配置方法，其将会同时启用 <code>I/O</code> 和时间相关的驱动。</p><p>然后是 <code>build</code> 方法，这个方法会返回一个运行时的实例。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">build</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;Runtime&gt;<br></code></pre></td></tr></table></figure><p>这个 <code>Runtime</code> 类型就是异步环境的核心了，它完成了诸如事件循环、<code>I/O</code> 交互还有计时器等等操作。</p><h2 id="简易的协程解释">简易的协程解释</h2><p>尽管从现在开始，我们就已经可以用 <code>Tokio</code> 提供的 <code>API</code> 来写协程了。。但是在这之前我还是想要插入一个关于协程原理的简要介绍。</p><p>在本篇博文的开头我们已经介绍了用户态线程等概念，但这很可能会让我们先入为主的认为，“用协程去写并发就一定是多线程的”，但是事实并不完全是这样。</p><p>例如使用 <code>js</code> 提供的 <code>Promise</code> 和 <code>async/await</code> 语法，你也可以写异步的程序，但是众所周知，<code>js</code> 的运行时实现几乎都是默认单线程执行的，这是怎么做到的？</p><p>类似的情况还发生在 <code>python</code> 的协程上，除非你手动编写多线程任务，否则<code>py</code> 几乎总是单线程运行的，但是通过 <code>generator</code> 和 <code>yield</code> 以及对应的语法糖实现，<code>py</code> 也可以实现协程。</p><p>如果你先前有了解过的，你可能听说过这样一个说法"协程是可以暂停的函数"，而很多协程的实现就是这样的！例如<code>Rust</code>或者<code>Kotlin</code>的<code>suspend</code>函数，其本质上都是基于的状态机可被"暂停"执行的函数。</p><div class="note note-warning">            <p>协程一般可以被分为有栈协程和无栈协程，使用编译期转换成状态机的一般为无栈协程，如果没有特殊说明，本文接下来提到的“协程”都为无栈协程。</p>          </div><p>哈？函数的执行可以在中途暂停吗？当然对于一个完整的函数是不行的，但是如果我把一个函数拆分成多个部分呢？</p><p>例如我们刚才的示例代码</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Result</span>&lt;()&gt; &#123;<br>    <span class="hljs-comment">// Open a connection to the mini-redis address.</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">client</span> = client::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-comment">// Set the key &quot;hello&quot; with value &quot;world&quot;</span><br>    client.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>()).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-comment">// Get key &quot;hello&quot;</span><br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = client.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;hello&quot;</span>).<span class="hljs-keyword">await</span>?;<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got value from the server; result=&#123;:?&#125;&quot;</span>, result);<br><br>    <span class="hljs-title function_ invoke__">Ok</span>(())<br>&#125;<br></code></pre></td></tr></table></figure><p>其中的 <code>.await</code> 关键字就将整个程序切分成了以下几个部分</p><ol type="1"><li>建立与 <code>mini-redis</code> 的连接</li><li>在数据库中设置键值对</li><li>通过键取出值</li></ol><p>假设我们将这几个操作放在一个 <code>match</code> 中（类似于其它类C语言的<code>switch</code>），然后生成一个变量用于记录当前的状态</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">async</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">fun</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">state</span> = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">match</span> state &#123;<br>        -<span class="hljs-number">1</span> =&gt; <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;done&quot;</span>),<br>        <span class="hljs-number">0</span> =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">client</span> = client::<span class="hljs-title function_ invoke__">connect</span>(<span class="hljs-string">&quot;127.0.0.1:6379&quot;</span>);<br>            state += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-number">1</span> =&gt; &#123;<br>            client.<span class="hljs-title function_ invoke__">set</span>(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>.<span class="hljs-title function_ invoke__">into</span>());<br>            state += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-number">2</span> =&gt; &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = client.<span class="hljs-title function_ invoke__">get</span>(<span class="hljs-string">&quot;hello&quot;</span>);<br>            state += <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-number">3</span> =&gt; &#123;<br>            <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;got value from the server; result=&#123;:?&#125;&quot;</span>, result);<br>            state += <span class="hljs-number">1</span>;<br>        &#125;<br>        _ =&gt; &#123;&#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这只是一段伪代码，但是基本思路差不多就是这样，将状态外提并，调度器就会轮流的执行任务队列中的各个协程，直到每个任务最后都完成。</p><p>注意，这是一个极度简化的模型，<code>Rust</code> 中的实现是每个异步函数的返回值都是一个<code>Future</code>，然后通过轮询和 <code>Waker</code> 的结合不断地 <code>poll</code> 直到任务完成。(关于这些词的含义我们会在后续的章节介绍)</p><!-- flag of hidden posts -->]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>RustLifeTimeKata学习记录</title>
    <link href="/2023/08/27/%E6%8A%80%E6%9C%AF/RustLifeTimeKata%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2023/08/27/%E6%8A%80%E6%9C%AF/RustLifeTimeKata%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>最近闲下来有点空，于是决定在玩 compose 之外重新看点 Rust 相关的内容，也因为我的 Rust 理解基本就是半吊子水平，一涉及到并发/协程 etc 就歇菜了。。。所以我决定从生命周期开始重新学起来，之后再看看 Tokio 的相关实现，这次学习的参考资料就是一本有关 Rust 生命周期实践的小册——<a href="https://github.com/tfpk/lifetimekata/">《Rust LIfetimeKata》</a>。除了一些概念上的讲解外，这个项目还有配套的一些习题，我也会把我的回答和理解放在这篇文章里。</p><h1 id="开始之前的闲聊">开始之前的闲聊</h1><p>在开始之前我们还是照例聊聊一些边角料，对于非 <code>CPP</code> 主力的大多数开发者来说，生命周期应该是一个相当陌生的东西，注意我说的不是业务层面的生命周期函数等，而是指引用等变量的存活时间段。</p><p>因为有 <code>GC</code> 兜底，无论是前端还是后端，都不用考虑到如此细枝末节的东西，<code>Runtime</code> 会帮助我们处理一切，真是太棒了！。。吗？</p><p>即使不考虑系统级编程或者量化交易等对性能有极端要求的场景，传统的后端业务在部分场景中也会因为 <code>GC</code> 的各种缺陷导致性能瓶颈<sup id="fnref:1" class="footnote-ref"><a href="#fn:1" rel="footnote"><span class="hint--top hint--rounded" aria-label="事实上这种场景非常罕见，我见到的例子只有 cloudflare 和 reddit 用 rust 重写自己相关业务用于获取性能提升的案例。">[1]</span></a></sup>，此时你就不得不用 <code>Rust/CPP</code> 去重写对应的实现。</p><p>但是没有 <code>GC</code> 的保护，去写内存安全的程序犹如在钢丝上行走，很多 <code>CPP</code> 开发的程序，尤其是那些没有引入 <code>Modern CPP</code> 的项目，就会很容易出现各种各样的内存安全问题。</p><p>生命周期是一种更加折中的方式，通过手动指定引用的生命周期约束的方式，编译器在大多数情况下可以正确的实现并获得与手动析构相同的性能，再配合各类智能指针，几乎可以覆盖大多数场景。</p><p>不过你真的需要生命周期吗？假设你所有的类型都使用值类型并保证不变性，再配合智能指针的使用，可以在保证一定性能的前提下同时避免生命周期的使用，但是如果这样玩的话，那还不如写 <code>Erlang</code> 呢😂。</p><h1 id="生命周期标注">生命周期标注</h1><p>前几章的内容比较简单，这里就放下 exercise 的答案。</p><h2 id="exercise">exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">identity</span>&lt;<span class="hljs-string">&#x27;a&gt;(number: &amp;&#x27;</span>a <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-string">&#x27;a i32 &#123;</span><br><span class="hljs-string">    number</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">//没什么可说的，返回值和输入值有一样的生命周期</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">split</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt;(text: &amp;<span class="hljs-string">&#x27;a str, delimiter: &amp;&#x27;</span>b <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-string">&#x27;a str&gt; &#123;</span><br><span class="hljs-string">    let mut last_split = 0;</span><br><span class="hljs-string">    let mut matches: Vec&lt;&amp;str&gt; = vec![];</span><br><span class="hljs-string">    for i in 0..text.len() &#123;</span><br><span class="hljs-string">        if i &lt; last_split &#123;</span><br><span class="hljs-string">            continue;</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">        if text[i..].starts_with(delimiter) &#123;</span><br><span class="hljs-string">            matches.push(&amp;text[last_split..i]);</span><br><span class="hljs-string">            last_split = i + delimiter.len();</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    if last_split &lt; text.len() &#123;</span><br><span class="hljs-string">        matches.push(&amp;text[last_split..]);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    matches</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">// 这个相对有意思一些，delimiter 是分隔符，而返回的值的资源全部从 text 中获取，所以后两者应该拥有相同的生命周期</span><br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">only_if_greater_hard</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt;(<br>    number: &amp;<span class="hljs-string">&#x27;a i32,</span><br><span class="hljs-string">    greater_than: &amp;&#x27;</span>b <span class="hljs-type">i32</span>,<br>    otherwise: &amp;<span class="hljs-string">&#x27;a i32,</span><br><span class="hljs-string">) -&gt; &amp;&#x27;</span>a <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-keyword">if</span> number &gt; greater_than &#123;<br>        number<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        otherwise<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 函数要么返回 number 要么返回 otherwise，所以这两者应该拥有至少一样长的生命周期，另一个函数参数则独自拥有一个生命周期</span><br></code></pre></td></tr></table></figure><h1 id="函数的生命周期省略规则">函数的生命周期省略规则</h1><p>在实际编写代码时，你可能会发现很多情况下并不需要为每个函数的引用参数都添加生命周期标注，这是因为 rust 编译器在这几年的演进过程中已经包含了很多对生命周期的改善，对于一些常见的模式，编译器可以自动推断出其生命周期约束。然而，这种自动推断有些时候会推导出完全不符合我们意图的生命周期。</p><p>参考相关<a href="https://github.com/rust-lang/reference/blob/master/src/lifetime-elision.md">文档</a>，对于函数的生命周期省略规则如下。</p><ol type="1"><li>函数参数中每个省略周期标注的参数都会被给予一个独立的生命周期参数。</li><li>如果参数中只使用了一个生命周期，则将其作为所有省略的输出生命周期。</li><li>对于方法签名， Self 引用的生命周期会被作为省略的输出生命周期。</li></ol><h2 id="exercise-1">exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">use</span> require_lifetimes::require_lifetimes;<br><br><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_a</span>&lt;<span class="hljs-string">&#x27;a&gt;(_number: &amp;&#x27;</span>a <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> (&amp;<span class="hljs-string">&#x27;a i32, &amp;&#x27;</span>a <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-built_in">unimplemented!</span>()<br>&#125;<br><br><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_b</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b, <span class="hljs-string">&#x27;c, &#x27;</span>d&gt;(<br>    _first_arg: &amp;<span class="hljs-string">&#x27;a i32,</span><br><span class="hljs-string">    _second_arg: &amp;&#x27;</span>b <span class="hljs-type">i32</span>,<br>    _third_arg: &amp;<span class="hljs-string">&#x27;c Option&lt;&amp;&#x27;</span>d <span class="hljs-type">i32</span>&gt;,<br>) &#123;<br>    <span class="hljs-built_in">unimplemented!</span>()<br>&#125;<br><br><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_c</span>&lt;<span class="hljs-string">&#x27;a&gt;(_first_arg: &amp;&#x27;</span>a <span class="hljs-type">i32</span>, _second_arg: &amp;<span class="hljs-string">&#x27;a i32) -&gt; &amp;&#x27;</span>a <span class="hljs-type">i32</span> &#123;<br>    <span class="hljs-built_in">unimplemented!</span>()<br>&#125;<br><br><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">example_d</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt;(_first_arg: &amp;<span class="hljs-string">&#x27;a i32, _second_arg: &amp;&#x27;</span>b <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-string">&#x27;a i32 &#123;</span><br><span class="hljs-string">    unimplemented!()</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h1 id="可变引用和容器">可变引用和容器</h1><p>其实可变引用这个词就很微妙，语义上说起是 <code>mutable</code> 是完全正确的，但是从实际应用角度来看，将其称之为独占引用会更恰当，与之相对的，常规的引用应该被称为共享引用。</p><p>之所以会这么称呼是因为 <code>rust</code> 限制一个变量的引用在同一时间只能有以下三种情况：</p><ol type="1"><li>不存在任何引用</li><li>任意个共享引用</li><li>一个独占引用（<code>mut reference</code>)</li></ol><p>所以 <code>mut reference</code> 相较于常规的 <code>reference</code> ，会有很多不同之处，尤其是在类型系统上的差异，这块的内容我们会在之后的章节讨论。</p><p>现在我们来看下列例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert_value</span>&lt;<span class="hljs-string">&#x27;a&gt;(</span><br><span class="hljs-string">    my_vec: &amp;&#x27;</span>a <span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-string">&#x27;a i32&gt;,</span><br><span class="hljs-string">    value: &amp;&#x27;</span>a <span class="hljs-type">i32</span>,<br>) &#123;<br>    my_vec.<span class="hljs-title function_ invoke__">push</span>(value)<br>&#125;<br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_vec</span> = <span class="hljs-built_in">vec!</span>[];<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">val1</span> = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">val2</span> = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-title function_ invoke__">insert_value</span>(&amp;<span class="hljs-keyword">mut</span> my_vec, &amp;val1);<br>    <span class="hljs-title function_ invoke__">insert_value</span>(&amp;<span class="hljs-keyword">mut</span> my_vec, &amp;val2);<br><br>    <span class="hljs-built_in">println!</span>(<span class="hljs-string">&quot;&#123;my_vec:?&#125;&quot;</span>);<br>&#125;<br><br></code></pre></td></tr></table></figure><p>这段代码看似没有什么问题，但是实际上没办法通过编译。</p><p>在这个例子中，函数签名将入参的所有生命周期都被约束到了 <code>'a</code> 一个生命周期上，这是一个非常严格的限制。</p><p><code>&amp;val1</code> 和 <code>&amp;val2</code> 在这个例子中生命周期一直持续到了 <code>main</code> 函数结束，第一次调用 <code>insert_value</code> 函数时，创建了一个 mut reference ，由于函数签名的约束，这几个入参至少有着同样长的生命周期，所以此处使用的临时引用也被约束至少活到 main 函数结束，第二次调用 <code>insert_value</code> 时也是同样的情况，此时就违背了引用的规则——同一时间只能有一个可变引用。</p><p>解决问题的方法同样也在函数签名之上，就像刚才提到的，所有入参都被约束到 <code>'a</code> 是一个极其严苛的约束，为了解决这个问题，我们首先来分析 <code>insert_value</code> 的意图。</p><p>这个函数通过一个类型为 <code>&amp;mut Vec&lt;&amp;i32&gt;</code> 的引用，并接受另一个类型为 <code>&amp;i32</code> 的引用，并将其插入到前一个引用指向的 <code>Vec</code> 中。这里涉及到三类引用，对容器的引用，容器内的引用类型的值，以及一个待插入容器的引用，为了分析方便，我们分别将其称为 <code>'r</code>,<code>'container</code> 以及 <code>'val</code>。</p><p>实际上这里在分析生命周期的时候还应该加上容器本身的生命周期，但这是多余的！因为容器的有效性依赖与其内部值的有效性，所以在这里，容器的生命周期至多与其所持有的值的生命周期一样长，也就是说，只要容器本身没被析构，其所包含的所有值都应该是有效的。所以，为了分析方便，我们在此处只需要考虑容器持有的值的共有最短生命周期 <code>'container</code> 。</p><p>在插入操作后，<code>value</code> 的生命周期同样也受到了原容器 <code>my_vec</code> 的关联，所以 <code>'val</code> 的生命周期肯定是比容器的生命周期以及容器的生命周期长的，其次，容器内的值都有着至少为 <code>'container</code> 的生命周期，所以有 <code>'val: 'container</code> 这层关系。也就是说我们可以将其简化到如下的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert_value</span>&lt;<span class="hljs-string">&#x27;r,&#x27;</span>container,<span class="hljs-string">&#x27;val&gt;(</span><br><span class="hljs-string">    my_vec: &amp;&#x27;</span>r <span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-string">&#x27;container i32&gt;,</span><br><span class="hljs-string">    value: &amp;&#x27;</span>val <span class="hljs-type">i32</span>,<br>)<br><span class="hljs-keyword">where</span> <span class="hljs-string">&#x27;val: &#x27;</span>container<br></code></pre></td></tr></table></figure><p>where 子句的约束 <code>'val: 'container</code> 读作 <code>'val</code> 长于 <code>'container</code>。</p><p>代码修改到这里其实已经可以通过编译了，但是其还可以进一步简化。</p><p>别忘了在插入后 <code>value</code> 已经成为容器所持有的值的一员，所以它们都有着至少一样长的生命周期！所以上述函数签名可以进一步修改如下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">insert_value</span>&lt;<span class="hljs-string">&#x27;r, &#x27;</span>val&gt;(my_vec: &amp;<span class="hljs-string">&#x27;r mut Vec&lt;&amp;&#x27;</span>val <span class="hljs-type">i32</span>&gt;, value: &amp;<span class="hljs-string">&#x27;val i32)</span><br></code></pre></td></tr></table></figure><p>是不是更加清爽了？当然之所以能这么修改，是因为生命周期是泛型参数，也就是说其满足里氏替换规则，换言之就是编译时每个入参和返回值的生命周期满足函数签名中对类型的约束就完全没问题。</p><p>在这例子中 <code>&amp;val1</code> 明显长于 <code>&amp;val2</code> ，但是其都满足修改后的 insert_value 对生命周期的约束 aka 对应生命周期是函数签名中对应部分的子类型。</p><p>关于生命周期和类型系统的联系，我们会在后续章节详细讨论。</p><h2 id="exercise-2">exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#[require_lifetimes(!)]</span><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">vector_set</span>&lt;<span class="hljs-string">&#x27;container, &#x27;</span>val&gt;(<br>    vector: &amp;<span class="hljs-string">&#x27;container mut Vec&lt;&amp;&#x27;</span>val <span class="hljs-type">str</span>&gt;,<br>    loc: <span class="hljs-type">usize</span>,<br>    new: &amp;<span class="hljs-string">&#x27;val str,</span><br><span class="hljs-string">) &#123;</span><br><span class="hljs-string">    // TODO: You will need to write this code yourself.</span><br><span class="hljs-string">    //       Don&#x27;</span>t worry, it<span class="hljs-string">&#x27;s only one line long.</span><br><span class="hljs-string">    if let Some(e) = vector.get_mut(loc) &#123;</span><br><span class="hljs-string">        *e = new;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><h1 id="生命周期与类型系统">生命周期与类型系统</h1><p>注意，这一部分并不是来自于 LifetimeKata，但是我认为讨论类型系统对于理解生命周期的应用非常有必要，所以我额外插入了此章节。</p><p>在开始之前我们先介绍一些之后会用到的术语。</p><blockquote><p>里氏替换原则：</p><p>子类可以替代基类工作，由于 Rust 没有常规面向对象的类设计，所以在这里我们指的是子类型。</p></blockquote><blockquote><p>型变：</p><p>此处指的是通过某些方式派生后的子类型相较派生后父类型的关系，可以参考<a href="https://en.wikipedia.org/wiki/Covariance_and_contravariance_(computer_science)">Wik</a></p></blockquote><p>好的，有了上述概念的支撑，我们可以继续来研究生命周期的问题了。</p><p>根据 Reference 的文档页面，对于常见的类型而言，其型变规则如下</p><table><thead><tr class="header"><th>Type</th><th>Variance in <code>'a</code></th><th>Variance in <code>T</code></th></tr></thead><tbody><tr class="odd"><td><code>&amp;'a T</code></td><td>covariant</td><td>covariant</td></tr><tr class="even"><td><code>&amp;'a mut T</code></td><td>covariant</td><td>invariant</td></tr><tr class="odd"><td><code>*const T</code></td><td></td><td>covariant</td></tr><tr class="even"><td><code>*mut T</code></td><td></td><td>invariant</td></tr><tr class="odd"><td><code>[T]</code> and <code>[T; n]</code></td><td></td><td>covariant</td></tr><tr class="even"><td><code>fn() -&gt; T</code></td><td></td><td>covariant</td></tr><tr class="odd"><td><code>fn(T) -&gt; ()</code></td><td></td><td>contravariant</td></tr><tr class="even"><td><code>std::cell::UnsafeCell&lt;T&gt;</code></td><td></td><td>invariant</td></tr><tr class="odd"><td><code>std::marker::PhantomData&lt;T&gt;</code></td><td></td><td>covariant</td></tr><tr class="even"><td><code>dyn Trait&lt;T&gt; + 'a</code></td><td>covariant</td><td>invariant</td></tr><tr class="odd"><td></td><td></td><td></td></tr></tbody></table><p>其中 covariant 指的是协变，invariant 不变，contravariant 逆变。</p><p>在这张表格中，只要属性上是允许 mutable 的，对于 <code>T</code> 来说，其都是不变的，反之则是协变的，而函数的入参相较于 <code>T</code> 来说则是逆变的。</p><p>我们引用 <a href="https://doc.rust-lang.org/nomicon/subtyping.html">Nomicon</a> 的例子来说明这些规则。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">debug</span>&lt;<span class="hljs-string">&#x27;a&gt;(a: &amp;&#x27;</span>a <span class="hljs-type">str</span>, b: &amp;<span class="hljs-string">&#x27;a str) &#123;</span><br><span class="hljs-string">    println!(&quot;a = &#123;a:?&#125; b = &#123;b:?&#125;&quot;);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">fn main() &#123;</span><br><span class="hljs-string">    let hello: &amp;&#x27;</span><span class="hljs-keyword">static</span> <span class="hljs-type">str</span> = <span class="hljs-string">&quot;hello&quot;</span>;<br>    &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;world&quot;</span>);<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">world</span> = &amp;world; <span class="hljs-comment">// &#x27;world has a shorter lifetime than &#x27;static</span><br>        <span class="hljs-title function_ invoke__">debug</span>(hello, world); <span class="hljs-comment">// hello silently downgrades from `&amp;&#x27;static str` into `&amp;&#x27;world str`</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以对于一个 <code>&amp;'a T</code>来说，接受一个 <code>&amp;'b T where 'b: 'a</code> 是完全没有问题的，这完全符合直觉，因为我们使用了一个生命周期长于约束的引用。</p><p>不加证明的，<code>&amp;'a U</code> 也能接受一个 <code>&amp;'a T</code> ，其中 <code>T</code> 为 <code>U</code> 的子类型（里氏替换规则）。</p><p>但是对于 <code>&amp;mut 'a T'</code> ，情况就变得特殊起来了，我们来看下列例子。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">assign</span>&lt;T&gt;(input: &amp;<span class="hljs-keyword">mut</span> T, val: T) &#123;<br>    *input = val;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">hello</span>: &amp;<span class="hljs-string">&#x27;static str = &quot;hello&quot;;</span><br><span class="hljs-string">    &#123;</span><br><span class="hljs-string">        let world = String::from(&quot;world&quot;);</span><br><span class="hljs-string">        assign(&amp;mut hello, &amp;world);</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    println!(&quot;&#123;hello&#125;&quot;); // use after free 😿</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>这段代码无法通过编译，很明显我们的 hello 变成了一个无效的悬垂引用，但是编译器是怎么知道的呢？</p><p>首先 assign 函数是没有任何问题的，这只是一个重新赋值的常见操作而已，问题应该发生在 main 函数的调用中。</p><p>对于 <figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">assign</span>&lt;T&gt;(input: &amp;<span class="hljs-keyword">mut</span> T, val: T)<br></code></pre></td></tr></table></figure></p><p>其在编译时被单例化成如下形式（<code>&amp;String</code> 可以被  Deref 成 <code>&amp;str</code>）</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">assign</span>(input: &amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-string">&#x27;static str, val: &amp;&#x27;</span><span class="hljs-keyword">static</span> <span class="hljs-type">str</span>)<br></code></pre></td></tr></table></figure><p>而我们传入的 <code>input</code> 是 <code>&amp;mut &amp;'static str</code>，<code>val</code> 是 <code>&amp;'b str</code></p><p>但是显然在调用的时候不可能满足 <code>'b: 'static</code>，故无法编译。</p><p>还有另外一个角度来说明，但是我不确定这样解释是正确的，我们在此假设对于泛型函数，若其调用能通过编译检查则有 rustc 的单例化对参数顺序无关。</p><p>那么可以有以下单例化形式：</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">assign</span>(input: &amp;<span class="hljs-keyword">mut</span> &amp;<span class="hljs-string">&#x27;b str, val: &amp;&#x27;</span>b <span class="hljs-type">str</span>)<br></code></pre></td></tr></table></figure><p>其中<strong>不满足</strong> <code>'b: 'static</code>，那么在调用时 <code>input</code> 的类型必须为其标注的类型或其子类型。</p><p>但 <code>&amp;mut T</code> 对于 <code>T</code> 是不变的，所以 <code>&amp;mut &amp;'static str</code> 不是 <code>&amp;mut &amp;'b str</code> 的子类型，故编译无法通过。</p><p>到此我们已经初步讨论了生命周期和类型系统相结合的情形，但这是显然不够的，如果需要进一步的了解相关信息，可以看看下列资料。</p><ol type="1"><li><a href="https://doc.rust-lang.org/nomicon/intro.html">《The Rustonomicon》</a> 死灵书，the black art of unsafe rust 🦀</li><li><a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program">《Common Rust Lifetime Misconceptions》</a></li><li><a href="https://doc.rust-lang.org/nightly/reference/">《The Reference》</a> 参考手册，大而全</li></ol><h1 id="复合类型上的生命周期">复合类型上的生命周期</h1><p>就像生命周期标注会出现在函数签名上，声明一个使用到引用的枚举或者结构体也会要求生命周期标注。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sample</span>&lt;<span class="hljs-string">&#x27;a&gt; &#123;</span><br><span class="hljs-string">    data: &amp;&#x27;</span>a <span class="hljs-type">str</span><br>&#125;<br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">AnotherSample</span>&lt;<span class="hljs-string">&#x27;a&gt; &#123;</span><br><span class="hljs-string">    Some(&amp;&#x27;</span>a <span class="hljs-type">str</span>),<br>    <span class="hljs-literal">None</span><br>&#125;<br></code></pre></td></tr></table></figure><p>这没什么稀奇的，就像编写带有常规泛型参数的结构体和枚举一样，不过变成了单引号开头的生命周期。</p><h2 id="exercise-3">exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Difference</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt; &#123;<br>    first_only: <span class="hljs-type">Vec</span>&lt;&amp;<span class="hljs-string">&#x27;a str&gt;,</span><br><span class="hljs-string">    second_only: Vec&lt;&amp;&#x27;</span>b <span class="hljs-type">str</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">find_difference</span>&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt;(sentence1: &amp;<span class="hljs-string">&#x27;a str, sentence2: &amp;&#x27;</span>b <span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> Difference&lt;<span class="hljs-string">&#x27;a, &#x27;</span>b&gt;<br></code></pre></td></tr></table></figure><h1 id="impl-块中的生命周期">impl 块中的生命周期</h1><p>当我们给复合类型加上了生命周期标注后，对应的 <code>impl</code> 语句也要带上对应的生命周期参数。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">Sample</span>&lt;<span class="hljs-string">&#x27;a, T&gt; &#123;</span><br><span class="hljs-string">    data: &amp;&#x27;</span>a T,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-string">&#x27;a, T&gt; Sample&lt;&#x27;</span>a, T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: &amp;<span class="hljs-string">&#x27;a T) -&gt; Sample&lt;&#x27;</span>a, T&gt; &#123;<br>        Sample &#123; data: data &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述例子还可以继续简化</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-string">&#x27;a, T&gt; Sample&lt;&#x27;</span>a, T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: &amp;<span class="hljs-string">&#x27;a T) -&gt; Self &#123;</span><br><span class="hljs-string">        Sample &#123; data &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>或者你可以让编译器帮你推断生命周期，但是我个人感觉这已经没什么必要了。。。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;<span class="hljs-string">&#x27;a, T&gt; Sample&lt;&#x27;</span>_, T&gt; &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(data: &amp;<span class="hljs-string">&#x27;a T) -&gt; Sample&lt;&#x27;</span>_, T&gt; &#123;<br>        Sample &#123; data &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="exercise-4">Exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-comment">// First, the struct:</span><br><br><span class="hljs-comment">/// This struct keeps track of where we&#x27;re up to in the string.</span><br><span class="hljs-keyword">struct</span> <span class="hljs-title class_">WordIterator</span>&lt;<span class="hljs-string">&#x27;s&gt; &#123;</span><br><span class="hljs-string">    position: usize,</span><br><span class="hljs-string">    string: &amp;&#x27;</span>s <span class="hljs-type">str</span><br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">WordIterator</span> &#123;<br>    <span class="hljs-comment">/// Creates a new WordIterator based on a string.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(string: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> WordIterator &#123;<br>        WordIterator &#123;<br>            position: <span class="hljs-number">0</span>,<br>            string<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/// Gives the next word. `None` if there aren&#x27;t any words left.</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_word</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">start_of_word</span> = &amp;<span class="hljs-keyword">self</span>.string[<span class="hljs-keyword">self</span>.position..];<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">index_of_next_space</span> = start_of_word.<span class="hljs-title function_ invoke__">find</span>(<span class="hljs-string">&#x27; &#x27;</span>).<span class="hljs-title function_ invoke__">unwrap_or</span>(start_of_word.<span class="hljs-title function_ invoke__">len</span>());<br>        <span class="hljs-keyword">if</span> start_of_word.<span class="hljs-title function_ invoke__">len</span>() != <span class="hljs-number">0</span> &#123;<br>            <span class="hljs-keyword">self</span>.position += index_of_next_space + <span class="hljs-number">1</span>;<br>            <span class="hljs-title function_ invoke__">Some</span>(&amp;start_of_word[..index_of_next_space]) <br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-literal">None</span><br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">fn</span> <span class="hljs-title function_">main</span>() &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-variable">text</span> = <span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;Twas brillig, and the slithy toves // Did gyre and gimble in the wabe: // All mimsy were the borogoves, // And the mome raths outgrabe. &quot;</span>);<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">word_iterator</span> = WordIterator::<span class="hljs-title function_ invoke__">new</span>(&amp;text);<br>    <br>    <span class="hljs-built_in">assert_eq!</span>(word_iterator.<span class="hljs-title function_ invoke__">next_word</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;Twas&quot;</span>));<br>    <span class="hljs-built_in">assert_eq!</span>(word_iterator.<span class="hljs-title function_ invoke__">next_word</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-string">&quot;brillig,&quot;</span>));<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h3 id="example-1">Example 1</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_word</span>&lt;<span class="hljs-string">&#x27;borrow&gt;(&amp;&#x27;</span>borrow <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-string">&#x27;borrow str&gt;</span><br></code></pre></td></tr></table></figure><p>这个可以编译，但是不太符合实际需求。因为独占引用和返回值都有着同样的生命周期约束，所以在后者没有被 <code>drop</code> 掉之前你甚至都不能再次调用这个函数。</p><h3 id="example-2">Example 2</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_word</span>&lt;<span class="hljs-string">&#x27;borrow&gt;(&amp;&#x27;</span>borrow <span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-string">&#x27;lifetime str&gt;</span><br></code></pre></td></tr></table></figure><p>这个是正确的，返回值拥有和 <code>self</code> 一样的生命周期约束。</p><h3 id="example3">Example3</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_word</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-string">&#x27;lifetime str&gt;</span><br></code></pre></td></tr></table></figure><p>在完整展开后这个和 Example2 的语义是一致的。</p><h3 id="example4">Example4</h3><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">next_word</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-type">str</span>&gt;<br></code></pre></td></tr></table></figure><p>在展开后这个和 Example1 的语义是一致的。</p><h1 id="特殊的生命周期们">特殊的生命周期们</h1><h2 id="static">'static</h2><p>这是一个极其具有迷惑性的生命周期，因为按照其他语言的理解来看，<code>static</code> 就是静态的变量，所以 <code>'static</code> 就意味着始终有效。。。吗？</p><p>尽管通过 <code>const</code> 修饰的或者字面量等都满足 <code>'static</code> 的约并且在程序运行期间始终有效，但是这并不意味着满足上述约束的所有变量都是始终有效的，关于这个问题的详细分析，可以参考这篇<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/common-rust-lifetime-misconceptions.md#2-if-t-static-then-t-must-be-valid-for-the-entire-program">文章</a>，以及其对应的<a href="https://github.com/pretzelhammer/rust-blog/blob/master/posts/translations/zh-hans/common-rust-lifetime-misconceptions.md#2-%E5%A6%82%E6%9E%9C-t-static-%E9%82%A3%E4%B9%88-t-%E7%9B%B4%E5%88%B0%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9D%9F%E4%B8%BA%E6%AD%A2%E9%83%BD%E4%B8%80%E5%AE%9A%E6%98%AF%E6%9C%89%E6%95%88%E7%9A%84">译文</a>。</p><h2 id="section">'_</h2><p>这个特殊的生命周期表示让编译器自动推断，在有些 <code>impl</code> 的实现中，若其不依赖于 <code>self</code> 之外的生命周期，通常可以标注 <code>'_</code>，另外在某些 <code>trait object</code> 的类型中也会用到，不过这块比较特殊，我们会在之后的章节中讨论。</p><h2 id="exercise-5">Exercise</h2><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">struct</span> <span class="hljs-title class_">UniqueWords</span> &#123;<br>    sentence: &amp;<span class="hljs-string">&#x27;static str,</span><br><span class="hljs-string">    unique_words: Vec&lt;&amp;&#x27;</span><span class="hljs-keyword">static</span> <span class="hljs-type">str</span>&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">UniqueWords</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(sentence: &amp;<span class="hljs-string">&#x27;static str) -&gt; UniqueWords &#123;</span><br><span class="hljs-string">        let unique_words = sentence</span><br><span class="hljs-string">            .split(&#x27;</span> <span class="hljs-string">&#x27;)</span><br><span class="hljs-string">            .collect::&lt;HashSet&lt;_&gt;&gt;()</span><br><span class="hljs-string">            .into_iter()</span><br><span class="hljs-string">            .collect::&lt;Vec&lt;_&gt;&gt;();</span><br><span class="hljs-string"></span><br><span class="hljs-string">        UniqueWords &#123;</span><br><span class="hljs-string">            sentence,</span><br><span class="hljs-string">            unique_words,</span><br><span class="hljs-string">        &#125;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    fn get_sorted_words(&amp;self) -&gt; Vec&lt;&amp;&#x27;</span>_ <span class="hljs-type">str</span>&gt; &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">unique_words</span> = <span class="hljs-keyword">self</span>.unique_words.<span class="hljs-title function_ invoke__">clone</span>();<br>        unique_words.<span class="hljs-title function_ invoke__">sort</span>();<br>        unique_words<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="trait-object-的生命周期省略规则">trait object 的生命周期省略规则</h1><p>与在 <code>Rust</code> 中我们遇到的其他情形不同，<code>trait object</code> 的生命周期有着特殊的规则。</p><p>在没有显式指定生命周期时，<code>trait object</code> 的默认生命周期为 <code>'static</code>，当使用 <code>'_</code> 时，编译器使用常规的生命周期省略规则推断。</p>在将<code>trait object</code>作为泛型参数的一部分时。省略规则就变得更为复杂了，完整的解释和示例可以参考 <a href="https://doc.rust-lang.org/reference/lifetime-elision.html#default-trait-object-lifetimes">Reference</a>以及其<a href="https://rustwiki.org/zh-CN/reference/lifetime-elision.html#%E9%BB%98%E8%AE%A4%E7%9A%84-trait%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F">译文</a>。<section class="footnotes"><div class="footnote-list"><ol><li><span id="fn:1" class="footnote-text"><span>事实上这种场景非常罕见，我见到的例子只有 cloudflare 和 reddit 用 rust 重写自己相关业务用于获取性能提升的案例。 <a href="#fnref:1" rev="footnote" class="footnote-backref"> ↩︎</a></span></span></li></ol></div></section>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>生命周期</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>操作系统复习笔记</title>
    <link href="/2023/05/28/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%8A%84%E6%9C%AC/"/>
    <url>/2023/05/28/%E7%AC%94%E8%AE%B0/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B0%8F%E6%8A%84%E6%9C%AC/</url>
    
    <content type="html"><![CDATA[<p>基本上就是各种考点的概念集合，简短无力但是有用。</p><h1 id="引论">引论</h1><h2 id="定义">定义</h2><p>介于计算机硬件和应用软件中间的软件系统</p><h2 id="主要功能">主要功能</h2><ol type="1"><li>处理器管理</li><li>存储管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li><li>网络和通信管理</li></ol><h2 id="基本特征">基本特征</h2><ol type="1"><li>并发性</li><li>共享性</li><li>虚拟性</li><li>不确定性</li></ol><h2 id="逻辑结构">逻辑结构</h2><ol type="1"><li>单内核结构，灵活快，调用复杂，难以维护</li><li>分层式结构，解耦，易于维护和验证，速度慢</li><li>微内核结构，一致性结构，易于拓展和修改，可以执行好，良好的分布式支持，效率高于分层</li></ol><h2 id="运行模型">运行模型</h2><ol type="1"><li>独立运行</li><li>嵌入到用户进程</li><li>作为独立进程运行</li></ol><h2 id="分类">分类</h2><ol type="1"><li>单道批处理</li><li>多道批处理</li><li>分时</li><li>实时</li><li>网络</li><li>分布式</li></ol><h1 id="处理器管理">处理器管理</h1><h2 id="进程">进程</h2><p>一个独立的可以调度的活动，aka 运行的程序</p><h2 id="进程与程序区别">进程与程序区别</h2><ol type="1"><li>程序是指令的静态有序集合，进程是一次CPU上的执行过程</li><li>进程有生命周期</li><li>进程是独立运行的基本单位</li><li>一个程序的执行可以包含多个进程，不同的进程也可以包含同一个程序</li><li>进程由程序段、数据段、PCB构成</li></ol><h2 id="进程结构">进程结构</h2><p>程序段 + 数据段 + PCB（Process Control Block）</p><h2 id="进程模型">进程模型</h2><h2 id="三态模型">三态模型</h2><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305281024447.png" alt="三状态模型" /><figcaption aria-hidden="true">三状态模型</figcaption></figure><ol type="1"><li>运行：获得了资源且正在执行</li><li>阻塞：发生了等待事件例如IO等</li><li>就绪：获得除CPU以外的所有资源</li></ol><h2 id="五态模型">五态模型</h2><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305281027544.png" alt="五状态模型" /><figcaption aria-hidden="true">五状态模型</figcaption></figure><h2 id="cpu调度策略">CPU调度策略</h2><p>三级调度是一种层次化的CPU调度策略，包括高级调度（作业调度）、低级调度（进程调度）和中级调度（内存调度）。高级调度选择作业调入内存，低级调度选择下一个执行的进程，中级调度优化内存利用。它们分别控制系统的长期资源分配、进程的执行顺序和内存中进程的调整，以提高系统性能和资源利用。</p><h2 id="周转时间带权周转时间响应时间">周转时间、带权周转时间、响应时间</h2><p>周转时间 = 完成时间 - 到达时间</p><p>带权周转 = 周转时间 / 运行时间</p><p>响应时间：发起请求到首次响应的时间间隔</p><h2 id="调度算法">调度算法</h2><h3 id="fcfs先来先服务">FCFS（先来先服务）</h3><p>维护一个队列，先来先服务</p><h3 id="spf-短作业优先">SPF （短作业优先）</h3><p>从后备队列中选择运行时间最短的</p><h3 id="rr-时间片轮转">RR （时间片轮转）</h3><p>CPU时间分片的FCFS</p><h3 id="hrrf高响应比优先">HRRF（高响应比优先）</h3><p><span class="math display">\[R_p = \frac{响应时间}{运行时间} = \frac{运行时间+等待时间}{运行时间} = 1 + \frac{等待时间}{运行时间}\]</span></p><p>每次计算后选择最高的执行</p><h3 id="优先级调度">优先级调度</h3><ol type="1"><li><p>静态优先级</p></li><li><p>动态优先级</p></li><li><p>抢占式：允许更高优先级的进程/线程抢占CPU</p></li><li><p>非抢占式：直到阻塞才会放弃使用权</p></li></ol><h1 id="进程同步与通信">进程同步与通信</h1><h2 id="同步机制的准则">同步机制的准则</h2><ol type="1"><li>空闲忙进</li><li>忙则等待</li><li>有限等待</li><li>让权等待</li></ol><h2 id="信号量">信号量</h2><h3 id="含义">含义</h3><p>P （Proberen） acquire</p><p>V （Verhogen） release</p><ol type="1"><li><span class="math inline">\(value &gt; 0\)</span> 资源可用数量</li><li><span class="math inline">\(value = 0\)</span> 资源为空</li><li><span class="math inline">\(value &lt; 0\)</span> 则 <span class="math inline">\(|value|\)</span> 为等待该资源的阻塞的进程数</li></ol><h3 id="伪代码">伪代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">typedef</span> <span class="hljs-keyword">struct</span> <br>&#123;<br>    <span class="hljs-type">int</span> value;<br>    <span class="hljs-keyword">struct</span> <span class="hljs-title class_">PCB</span>* L;<br>&#125; Semaphore;<br></code></pre></td></tr></table></figure><h4 id="p">P</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">P</span><span class="hljs-params">(Semaphore S)</span> </span>&#123;<br>    lock interrupts;<br>    s.value = s.value - <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span>(s.value &lt; <span class="hljs-number">0</span>) &#123;<br>        i.status = <span class="hljs-string">&#x27;block&#x27;</span>;<br>        <span class="hljs-built_in">Insert</span>(BlockQueue, i)<br>        unlock interrupts;<br>        <span class="hljs-built_in">Scheduler</span>(); <span class="hljs-comment">//执行调度程序调度另一就绪进程运行</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        unlock interrupts;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="v">V</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">V</span><span class="hljs-params">(Semaphore S)</span> </span>&#123;<br>    lock interrupts;<br>    s.value = s.value + <span class="hljs-number">1</span>;<br><br>    <span class="hljs-keyword">if</span>(s.value &lt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">Remove</span>(BlockQueue, i);<br>        i.status = <span class="hljs-string">&#x27;ready&#x27;</span>;<br>        <span class="hljs-built_in">Insert</span>(ReadyQueue, i); <br>    &#125; <br>    <br>    unlock interrupts;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="临界区保护语言模型生成内容">临界区保护（语言模型生成内容）</h2><p>在临界区保护中，存在几条必须遵守的原则，其中最有可能的原则包括：</p><ol type="1"><li><p>互斥性（Mutual Exclusion）：在任何时刻，只允许一个进程进入临界区访问共享资源。这是最基本的原则，确保共享资源不会同时被多个进程访问，避免数据的不一致性和竞态条件的发生。</p></li><li><p>公平性（Fairness）：每个进程有公平的机会进入临界区。确保各个进程按照一定的顺序和优先级获得临界区的访问权，避免某个进程长时间占用临界区而导致其他进程饥饿。</p></li><li><p>有限等待（Bounded Waiting）：任何进程在获取临界区访问权限前都有一个有限的等待时间。确保没有进程永远被其他进程拒绝访问临界区，避免产生死锁等问题。</p></li></ol><p>这些原则的遵守可以提高临界区保护的有效性和可靠性。</p><p>互斥性是最重要的原则，因为它保证了共享资源在同一时间只能被一个进程访问，避免了数据不一致性和竞态条件。如果没有互斥性，多个进程同时修改共享资源可能导致数据错乱或无效的结果。</p><p>公平性是为了确保每个进程都有公平的机会访问临界区，避免某个进程长时间占用临界区导致其他进程无法获得资源。公平性原则可以提高系统的公正性和可靠性。</p><p>有限等待原则是为了防止某个进程永远等待临界区访问的情况发生，保证所有进程都能够在有限的时间内获得临界区的访问权限。这样可以避免系统陷入死锁状态，提高系统的稳定性和可用性。</p><h2 id="死锁">死锁</h2><h3 id="原因">原因</h3><ol type="1"><li>系统资源不足</li><li>进程推进顺序不当</li></ol><h3 id="必要条件">必要条件</h3><ol type="1"><li>互斥条件，进程对所获得的资源进行排他性使用。</li><li>请求和保持条件，一个进程请求资源得不到满足而阻塞自己时，并不释放已分配给它的资源</li><li>不可抢占条件，在该进程的资源未使用完毕时，其他进程不可抢占</li><li>循环等待条件，至少两个进程构成了循环等待链</li></ol><h3 id="银行家算法">银行家算法</h3><h2 id="进程通信的方式">进程通信的方式</h2><h3 id="低级通信">低级通信</h3><p>信号量等，一般用于互斥与同步的工具。</p><h3 id="高级通信">高级通信</h3><h4 id="共享内存">共享内存</h4><p>划出一块内存区作为共享数据区，待通信的进程双方将虚拟地址空间映射到共享分区上</p><h4 id="消息缓冲">消息缓冲</h4><ol type="1"><li>发送者设置发送区并填入待发送的消息</li><li>发送者申请缓冲区并将消息从发送区送到缓冲区，并附加发送进程和消息的元信息至缓冲区，最后将缓冲区挂载到接收方的消息链上</li><li>接收者设置接受区</li><li>从消息链上取下第一条消息复制到接受区并释放该消息缓冲区</li></ol><h4 id="信箱">信箱</h4><ol type="1"><li>若接收方信箱已满则发送方阻塞</li><li>若接收方接收信息时信箱为空则阻塞</li></ol><p>// 有点像是 golang 的 channel ？</p><h4 id="管道通信">管道通信</h4><ol type="1"><li>管道是一种单向通信方式，可以在一个进程中创建管道，然后将其连接到另一个相关进程。</li><li>管道可以分为匿名管道（Anonymous Pipe）和命名管道（Named Pipe）两种类型。</li><li>匿名管道是一种临时的、单向的管道，通常用于有亲缘关系（如父子进程）的相关进程之间通信。</li><li>命名管道是一种具有持久性的、命名的管道，可以在无亲缘关系的进程之间进行通信。</li><li>管道的操作方式是基于文件描述符（File Descriptor）进行的，进程通过文件描述符来读取和写入管道中的数据。</li><li>管道可以实现进程间的单向通信，其中一个进程负责写入数据到管道，另一个进程负责从管道中读取数据。</li><li>管道通信是一种同步阻塞的通信方式，当管道为空时，读取进程会被阻塞，直到有数据可读取；当管道满时，写入进程会被阻塞，直到有空间可写入。</li></ol><h1 id="存储管理">存储管理</h1><h2 id="地址相关的名词">地址相关的名词</h2><ol type="1"><li>逻辑地址：程序中的地址</li><li>逻辑地址空间：一个程序的所有逻辑地址的集合</li><li>物理地址：实际内存中的地址</li><li>物理地址空间：全部存储单元的物理地址的集合</li><li>虚拟地址空间：程序能用到的整个地址的范围</li></ol><h2 id="地址转换算法">地址转换算法</h2><p><span class="math display">\[物理地址=逻辑地址+分区起始地址=页号 \times 页长+页内地址=段起始地址+段内地址\]</span></p><h2 id="分区分配算法">分区分配算法</h2><ol type="1"><li>首次适应法：按内存地址递增找到第一个满足的</li><li>最佳适应法：从最小空闲分区开始递增查找到第一个满足的</li><li>最差适应法：从最大空闲分区开始分配</li></ol><h2 id="段页式存储管理">段页式存储管理</h2><p><span class="math display">\[逻辑地址=段号+段内地址+页内地址\]</span></p><h2 id="页置换算法">页置换算法</h2><h3 id="opt最佳置换">OPT（最佳置换）</h3><p>页访问序列已知，每次置换时找最长时间后才被访问的页面</p><h3 id="fifo-first-in-first-out">FIFO (First in First out)</h3><p>维护循环队列</p><h3 id="lru-最近最久未使用">LRU (最近最久未使用)</h3><p>两种方式</p><ol type="1"><li>维护一个链表，表顺序按照最近的访问排序，表头为上一次的访问</li><li>每个块维护一个计数器，当有页面访问时置零，否则自增1，置换时找计数器最大的块</li></ol><h1 id="设备管理">设备管理</h1><h2 id="io设备控制方式">IO设备控制方式</h2><p>// 此节为语言模型生成内容</p><h3 id="程序直接io控制忙查询">程序直接IO控制（忙查询）</h3><h4 id="特点">特点</h4><ol type="1"><li>IO操作由程序直接控制，程序通过查询IO设备的状态来判断是否准备好进行IO操作。</li><li>需要程序主动轮询IO设备状态，属于主动方式，占用CPU资源较多。</li><li>简单实现，适用于设备处理速度较快，对实时性要求不高的情况。</li></ol><h4 id="区别">区别</h4><ol type="1"><li>相对于其他控制方式，程序直接IO控制实现简单，无需额外硬件支持。</li><li>但是程序需要主动查询IO设备状态，占用大量CPU资源，效率较低。</li><li>对于设备处理速度较慢、实时性要求高的情况，程序直接IO控制可能无法满足要求。</li></ol><h3 id="程序中断io控制中断处理">程序中断IO控制（中断处理）</h3><h4 id="特点-1">特点</h4><ol type="1"><li>通过中断机制实现IO控制，设备在完成IO操作后触发中断信号，通知CPU进行处理。</li><li>CPU在收到中断信号后会暂停当前任务，转而处理中断服务程序，然后恢复原任务继续执行。</li><li>减少了程序主动查询设备状态的开销，提高了CPU利用率和系统响应性。</li></ol><h4 id="区别-1">区别</h4><ol type="1"><li>相对于程序直接IO控制，程序中断IO控制通过中断机制实现，减少了程序主动查询设备状态的开销。</li><li>CPU在收到中断信号后会暂停当前任务，转而处理中断服务程序，提高了CPU利用率和系统响应性。</li><li>需要中断控制器的支持，对硬件要求较高。</li></ol><h3 id="dma控制方式">DMA控制方式</h3><h4 id="特点-2">特点</h4><ol type="1"><li>DMA（Direct Memory Access）是一种无需CPU干预的IO数据传输方式。</li><li>DMA控制器直接将数据从IO设备读取到内存或从内存写入到IO设备，减少了CPU的参与。</li><li>提高了数据传输速率和系统性能，释放了CPU的负担。</li></ol><h4 id="区别-2">区别</h4><ol type="1"><li>相对于程序直接IO控制和程序中断IO控制，DMA控制方式无需CPU的干预，通过DMA控制器直接进行数据传输。</li><li>DMA控制方式可以提高数据传输速率和系统性能，减少了CPU的参与，释放了CPU的负担。</li><li>需要硬件支持，包括DMA控制器和能与之配合的IO设备。</li></ol><h3 id="io通道控制方式">IO通道控制方式</h3><h4 id="特点-3">特点</h4><ol type="1"><li>IO通道是一种专用的硬件设备，用于处理IO操作。</li><li>IO通道独立于CPU，具有自己的控制逻辑和寄存器，能够执行IO操作。</li><li>通过命令和参数设置，CPU可以委托IO通道执行特定的IO任务，然后继续执行其他任务。</li></ol><h4 id="区别-3">区别</h4><ol type="1"><li>相对于其他控制方式，IO通道控制方式使用专用的硬件设备进行IO操作，独立于CPU。</li><li>IO通道可以独立执行IO任务，减少了CPU的负担，提高了系统的并发性能。</li><li>需要特定的硬件支持，对于复杂IO操作和高性能要求的场景，IO通道控制方式是一种有效的选择。</li></ol><h2 id="虚拟设备技术---spooling">虚拟设备技术 - Spooling</h2><p>Spooling （Simultaneous Peripheral Operations On-Line）</p><p>外部设备联机并行操作 aka 假脱机</p><h3 id="实现原理">实现原理</h3><p>输入输出井</p><h3 id="特点-4">特点</h3><ol type="1"><li>提高了IO速度</li><li>将独占设备改造成共享设备</li><li>实现了虚拟设备功能</li></ol><h2 id="缓冲技术">缓冲技术</h2><p>硬件缓冲器或者内存缓冲区</p><h3 id="单双缓冲">单双缓冲</h3><p>单缓冲缓冲区为临界资源，无法并行IO操作。</p><p>双缓冲（缓冲对换）</p><p>设置双缓冲后，设备输入时先将数据送入第一个缓冲区，第个缓冲区装满数据后再转向第二个缓冲区输入数据，此时操作系统可以从第一个缓冲区中取出数据传给用户进程：当第一个缓冲区的数据被操作系统全部取走后，设备又可以重新转向第二个缓冲区输入数 据，而此时，操作系统又可以从第二个缓冲区中取走数据：依此重复进行直至输入结束。</p><h3 id="循环缓冲">循环缓冲</h3><p>多个缓冲区组成队列，标记三种状态，空E、满G、当前C</p><h3 id="缓冲池">缓冲池</h3><p>同种类型的缓冲区链接成队列</p><ol type="1"><li>空缓冲区队列EmQ</li><li>输入缓冲区队列InQ</li><li>输出缓冲区队列OutQ</li></ol><p>四个工作缓冲区</p><ol type="1"><li>收容输入Hin</li><li>提取输入Sin</li><li>收容输出Hout</li><li>提取输出Sout</li></ol><h3 id="cache">Cache</h3><p>可以保存数据副本的高速存储器</p><h2 id="磁盘">磁盘</h2><h3 id="相关名词">相关名词</h3><ol type="1"><li>寻道时间：磁头移动到磁道位置的平均时间</li><li>旋转延迟时间：磁头到达位置后扇区旋转到磁头下方的平均时间，旋转延迟通常约为旋转时间的一半，<span class="math inline">\(平均访问时间 = 寻道时间+旋转延迟时间\)</span><br /></li><li>数据传输时间：实际读写磁盘数据的时间</li></ol><h3 id="磁盘调度算法">磁盘调度算法</h3><h4 id="fcfs">FCFS</h4><p>先来先服务</p><h4 id="sstf-最短寻道时间优先">SSTF (最短寻道时间优先)</h4><p>每次找离当前磁头位置最近的下一个位置</p><h4 id="scan-扫描">SCAN (扫描)</h4><p>磁头朝一个方向扫描，到头后返回扫描</p><h4 id="elevator-电梯算法">Elevator (电梯算法)</h4><p>没有访问请求时磁头不动，有访问时磁头来回扫描，每次选择离当前磁头最近的位置方向开始扫描</p><h4 id="cscan-循环扫描">CSCAN (循环扫描)</h4><p>磁头处理请求时只往一个方向移动，没有请求时不运动</p><h1 id="文件系统">文件系统</h1><h2 id="文件属性和特点">文件属性和特点</h2><h3 id="属性">属性</h3><ol type="1"><li>本身的数据信息</li><li>附加的组织与管理信息（元信息）</li></ol><h3 id="特点-5">特点</h3><ol type="1"><li>保存性</li><li>按名存取</li><li>一组信息集合</li></ol><h2 id="虚拟文件系统的设计思路">虚拟文件系统的设计思路</h2><p>虚拟层定义用户一致性接口，实现层通过开关表等进行文件系统转换</p><h2 id="逻辑结构-1">逻辑结构</h2><p>无结构和有结构文件</p><ol type="1"><li>流式文件：有序字符的集合，按照字符组的长度读写信息</li><li>记录式文件：由如果逻辑记录构成的序列 //看成数据库就行</li></ol>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>操作系统</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微机原理学习笔记</title>
    <link href="/2023/03/14/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2023/03/14/%E7%AC%94%E8%AE%B0/%E5%BE%AE%E6%9C%BA%E5%8E%9F%E7%90%86%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="开始之前">开始之前</h1><p>好吧，不太清楚究竟是怎么回事，但是貌似我们学校的《微机原理》改名成了《汇编与接口》。汇编这玩意儿还是有点意思的，就是写起来对人来说太不友好了（ 不过除了非常底层的优化外，貌似手撸汇编在现在的意义没那么大（？</p><h2 id="实验环境搭建">实验环境搭建</h2><p>环境搭建也算是老生常谈的话题了。。基本上每学一门新语言都要经历这个步骤。</p><p>注意这次我们所需的是 32 位的 <code>masm</code> 环境，所以我们需要 <code>visual studio</code> 来提供 <code>msvc</code> 工具链。</p><p>由于部分用于代码高亮和自动补全的的插件仍然没有适配 <code>vs2022</code>，所以我们需要安装 <code>vs2019</code>。</p><p>这是<a href="https://visualstudio.microsoft.com/zh-hans/vs/older-downloads/">下载链接</a>，注意，你得注册一个微软账户才能在上面下载，简单来说就是去注册一个 outlook 邮箱。</p><p>如图所示，在安装时勾选"使用c++的桌面开发"即可。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/images/Snipaste_2023-03-17_09-10-20.png" /></p><p>在安装后打开 <code>vs</code>，进入项目后点击顶栏的拓展-管理拓展，然后搜索 <code>asmdude</code> 并点击安装，然后关闭并重新进入 <code>vs</code> 即可启用拓展 。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/images/Snipaste_2023-03-17_09-15-40.png" /></p><p>接下来新建一个空项目然后按照下图操作。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/images/Snipaste_2023-03-17_09-22-03.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/images/Snipaste_2023-03-17_09-22-24.png" /></p><p>...并点击确定。 右键右侧的源文件并新建一个 <code>main.asm</code>，当然命名是无所谓的。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.386</span>    <br><span class="hljs-meta">.model</span> flat, c<br><span class="hljs-meta">option</span> casemap :none<br><br>includelib libcmt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br><span class="hljs-meta">EXTERN</span> printf :PROC <span class="hljs-comment">; declare printf</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    HelloWorld <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;Hello World!:-)&quot;</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br>    <span class="hljs-keyword">push</span> offset HelloWorld<br>    <span class="hljs-keyword">call</span> printf<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">ret</span><br>main ENDP<br>END<br></code></pre></td></tr></table></figure><p>注意我们现在是在编写32位的汇编，所以请确保在 <code>x86</code> 的 <code>Debug</code> 模式下编译和调试，然后点击顶栏的绿色三角。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/images/20230317093317.png" /></p><p>到此就完成了环境的搭建。</p><h1 id="零碎小玩意儿">零碎小玩意儿</h1><p>基本上这节就是些小知识点，因为编排问题没有加进正文里，所以统一放这儿了。</p><h2 id="ia-32中的数据单位">IA-32中的数据单位</h2><table><thead><tr class="header"><th>大小（Bits）</th><th>单位</th></tr></thead><tbody><tr class="odd"><td>1</td><td>比特 (Bit)</td></tr><tr class="even"><td>4</td><td>半字节 (Nibble)</td></tr><tr class="odd"><td>8</td><td>字节 (Byte)</td></tr><tr class="even"><td>16</td><td>字 (Word)</td></tr><tr class="odd"><td>32</td><td>双字 (Double Word)</td></tr><tr class="even"><td>64</td><td>四字 (Quad Word)</td></tr></tbody></table><h2 id="stdcall-调用约定">stdcall 调用约定</h2><p><code>stdcall</code> 是一种常见的调用约定，其中函数的参数通过栈传递，函数的参数是从右到左依次推送到栈上，而栈上的每个参数占据4字节的空间。</p><h2 id="琐碎的指令们">琐碎的指令们</h2><h3 id="跳转指令">跳转指令</h3><table><thead><tr class="header"><th>跳转指令</th><th>功能</th></tr></thead><tbody><tr class="odd"><td>jmp</td><td>unconditional jump</td></tr><tr class="even"><td>je</td><td>jump if equal</td></tr><tr class="odd"><td>jne</td><td>jump if not equal</td></tr><tr class="even"><td>jl</td><td>jump if less</td></tr><tr class="odd"><td>jg</td><td>jump if greater</td></tr><tr class="even"><td>jle</td><td>jump if less or equal</td></tr><tr class="odd"><td>jge</td><td>jump if greater or equal</td></tr><tr class="even"><td>jo</td><td>jump if overflow</td></tr><tr class="odd"><td>jno</td><td>jump if not overflow</td></tr><tr class="even"><td>js</td><td>jump if sign (比较结果为负数)</td></tr><tr class="odd"><td>jns</td><td>jump if not sign</td></tr><tr class="even"><td>jc</td><td>jump if carry (产生进位)</td></tr><tr class="odd"><td>jnc</td><td>jump if not carry</td></tr></tbody></table><p>值得注意的是，有符号数使用 <code>jg</code> 和 <code>jl</code>，而无符号数使用 <code>ja</code> 和 <code>jb</code></p><h3 id="除法指令-div">除法指令 div</h3><p>这一节为语言模型生成内容，参考 <code>promt</code> 如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prompt">请介绍 IA-32 masm 中的 div 指令并举一个用其判断奇偶数的例子<br></code></pre></td></tr></table></figure></p><p><code>div</code>指令是IA-32汇编语言中的除法指令，用于将一个32位的无符号整数除以一个操作数，并将商存储在EDX:EAX寄存器对中的EAX寄存器中，余数存储在EDX寄存器中。</p><p><code>div</code>指令的基本语法如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">div</span> operand<br></code></pre></td></tr></table></figure><p>其中，<code>operand</code>表示除数。</p><p>为了判断一个数是奇数还是偶数，可以使用<code>div</code>指令来计算除以2的余数。如果余数为0，则说明被除数是偶数；如果余数为1，则说明被除数是奇数。</p><p>下面是一个使用<code>div</code>指令判断奇偶数的示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">13</span> <span class="hljs-comment">; 被除数，例如，我们判断13是奇数还是偶数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span>  <span class="hljs-comment">; 清零EDX寄存器，用于存储余数</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">2</span>  <span class="hljs-comment">; 除数，即2</span><br><span class="hljs-keyword">div</span> <span class="hljs-built_in">ecx</span>     <span class="hljs-comment">; 将eax中的值除以ecx，商存储在eax，余数存储在edx</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span>  <span class="hljs-comment">; 比较余数和0</span><br><span class="hljs-keyword">jne</span> odd     <span class="hljs-comment">; 如果余数不等于0，跳转到odd标签</span><br><span class="hljs-comment">; 偶数的处理</span><br><span class="hljs-comment">; 偶数的代码逻辑</span><br><span class="hljs-keyword">jmp</span> done    <span class="hljs-comment">; 跳转到done标签结束</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">odd:</span>        <span class="hljs-comment">; odd标签</span><br><span class="hljs-comment">; 奇数的处理</span><br><span class="hljs-comment">; 奇数的代码逻辑</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">done:</span>       <span class="hljs-comment">; done标签</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们将13存储在<code>eax</code>寄存器中作为被除数，将2存储在<code>ecx</code>寄存器中作为除数。然后使用<code>div ecx</code>指令进行除法运算，商存储在<code>eax</code>寄存器中，余数存储在<code>edx</code>寄存器中。接下来，我们通过比较余数和0的值来判断奇偶性，如果余数不等于0，则跳转到<code>odd</code>标签，执行奇数的处理逻辑；如果余数等于0，则跳转到<code>done</code>标签，执行偶数的处理逻辑。</p><p>这是一个简单的例子，演示了如何使用<code>div</code>指令来判断一个数的奇偶性。根据实际需求，您可以根据<code>eax</code>寄存器的值进行不同的处理。</p><h3 id="交换指令-xchg">交换指令 xchg</h3><p>此节为语言模型生成内容，参考 <code>prompt</code> 如下 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs prompt">介绍 IA-32 masm 中的 xchg 指令并举一个用其交换数据的例子<br></code></pre></td></tr></table></figure></p><p><code>xchg</code>指令是IA-32汇编语言中的交换指令，用于交换两个操作数的值。它可以用于交换寄存器、内存和寄存器之间的数据。</p><p><code>xchg</code>指令的基本语法如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">xchg</span> destination, source<br></code></pre></td></tr></table></figure><p>其中，<code>destination</code>和<code>source</code>表示要交换值的操作数。</p><p>下面是一个使用<code>xchg</code>指令交换两个变量值的示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">10</span>  <span class="hljs-comment">; 变量A的初始值为10</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">20</span>  <span class="hljs-comment">; 变量B的初始值为20</span><br><br><span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span>  <span class="hljs-comment">; 交换变量A和变量B的值</span><br><br><span class="hljs-comment">; 现在eax中存储的是交换后的变量B的值，ebx中存储的是交换后的变量A的值</span><br></code></pre></td></tr></table></figure><p>在上述示例中，我们使用<code>mov</code>指令将变量A的初始值10存储在<code>eax</code>寄存器中，将变量B的初始值20存储在<code>ebx</code>寄存器中。然后使用<code>xchg</code>指令交换<code>eax</code>和<code>ebx</code>的值。交换后，<code>eax</code>寄存器中存储的是变量B的值20，<code>ebx</code>寄存器中存储的是变量A的值10。</p><p>通过<code>xchg</code>指令，我们可以方便地交换两个变量的值，而不需要借助额外的寄存器或内存位置。这在某些算法或数据处理任务中可能会有用。</p><h3 id="逻辑与指令-test">逻辑与指令 test</h3><p><strong>此节使用语言模型生成，prompt 格式同前节</strong></p><p><code>test</code>指令是IA-32汇编语言中的逻辑与（AND）操作指令。它执行两个操作数之间的位逻辑与运算，并根据结果设置标志寄存器的状态。</p><p><code>test</code>指令的基本语法如下：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">test</span> destination, source<br></code></pre></td></tr></table></figure><p>其中，<code>destination</code>和<code>source</code>表示要进行逻辑与运算的操作数。</p><p><code>test</code>指令执行以下操作：</p><ol type="1"><li>将<code>destination</code>和<code>source</code>进行逻辑与运算，将结果存储在临时位置中。</li><li>根据结果设置标志寄存器的状态，特别是设置零标志位（ZF）和进位标志位（CF）。</li></ol><p><code>test</code>指令常用于条件判断、位掩码和清零操作等。</p><p>下面是一些<code>test</code>指令的使用示例：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span>  <span class="hljs-comment">; 检查eax寄存器是否为零</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0xFF</span><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0x0F</span> <span class="hljs-comment">; 检查ebx寄存器的低4位是否都为1</span><br><br><span class="hljs-keyword">test</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">edx</span>  <span class="hljs-comment">; 检查edx寄存器是否为零</span><br><span class="hljs-keyword">jz</span> <span class="hljs-meta">zero</span>        <span class="hljs-comment">; 如果为零，跳转到zero标签处</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">zero:</span><br>    <span class="hljs-comment">; 执行一些操作</span><br></code></pre></td></tr></table></figure><p>在第一个示例中，将常数10存储在<code>eax</code>寄存器中，然后对<code>eax</code>寄存器和自身执行逻辑与运算。这将检查<code>eax</code>寄存器的值是否为零，并根据结果设置标志寄存器的状态。</p><p>在第二个示例中，将常数0xFF存储在<code>ebx</code>寄存器中，然后对<code>ebx</code>寄存器和常数0x0F执行逻辑与运算。这将检查<code>ebx</code>寄存器的低4位是否都为1，并根据结果设置标志寄存器的状态。</p><p>在第三个示例中，将<code>edx</code>寄存器与自身执行逻辑与运算。这将检查<code>edx</code>寄存器的值是否为零，并根据结果设置标志寄存器的状态。如果<code>edx</code>寄存器为零，将会发生跳转到<code>zero</code>标签处执行相应的操作。</p><p>通过<code>test</code>指令，我们可以执行逻辑与运算并根据结果设置标志寄存器的状态，以便进行条件判断和控制程序的流程。</p><h1 id="处理器结构">处理器结构</h1><h2 id="基本结构">基本结构</h2><ol type="1"><li>算术逻辑单元 (<code>ALU</code>)</li><li>寄存器</li><li>指令处理单元</li></ol><h2 id="寄存器">寄存器</h2><p>寄存器就是 <code>CPU</code> 暂时存取数据的地方，在 <code>IA-32</code> 基本执行环境中包括8个32位通用寄存器，6个12位段寄存器，以及32位标志寄存器和指令指针。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/%E5%AF%84%E5%AD%98%E5%99%A8.png" alt="常用寄存器" /><figcaption aria-hidden="true">常用寄存器</figcaption></figure><h3 id="通用寄存器">通用寄存器</h3><p>通用寄存器一般是指处理器中最长使用的整数存取寄存器，可以用于保存整型数据和地址等。</p><p>在上图的寄存器展示中，这些32位寄存器也可以当作16位寄存器使用，只需要去除寄存器名前的 "E" 即可，例如 <code>AX</code>, <code>BX</code>, <code>SI</code>, <code>DI</code> 等等。</p><p>甚至可以将寄存器的低16位拆成2个8位寄存器使用，例如图中 <code>EAX</code> 的 <code>D15</code>-<code>D8</code> 就对应着 <code>AH</code> ，而低八位的 <code>D7</code>-<code>D0</code> 则对应着 <code>AL</code> 寄存器。</p><h4 id="通用寄存器的常用用途">通用寄存器的常用用途</h4><ol type="1"><li><code>EAX</code>: 最常用的寄存器，函数调用传参，作为累加器，算数运算和外设传送信息等</li><li><code>EBX</code>: 基址寄存器，长用来存放存储器地址</li><li><code>ECX</code>: 计数器</li><li><code>EDX</code>: 数据寄存器，可用来存放数据</li><li><code>ESI</code>: 源变址寄存器，用于指向字符串或数组的源操作数。源操作数是指保存传送结果或运算结果的寄存器。</li><li><code>EDI</code>: 目的变址寄存器，用于指向字符串或数组的目的操作数，目的操作数是指保存传送结果或者运算结果的操作数。</li><li><code>EBP</code>: 基址指针寄存器，默认指向程序堆栈区域的数据，主要用于在子程序中访问通过堆栈传递的参数和局部变量。</li><li><code>ESP</code>: 堆栈指令寄存器，<em>专门</em>用于指向程序堆栈区域顶部的数据，在涉及堆栈操作时会自动变化。</li></ol><h3 id="标志寄存器">标志寄存器</h3><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305201859366.png" alt="标志寄存器" /><figcaption aria-hidden="true">标志寄存器</figcaption></figure><p><code>OF</code> 溢出标志、<code>SF</code> 符号标志、<code>ZF</code> 零标志、<code>PF</code> 奇偶标志、<code>CF</code> 进位标志、<code>AF</code>调整标志</p><h3 id="专用寄存器">专用寄存器</h3><ol type="1"><li>指令寄存器 <code>EIP</code>: 保存将要执行指令的地址</li><li>段寄存器: <code>CS</code> <code>DS</code> <code>SS</code> <code>ES</code> <code>FS</code> <code>GS</code></li><li>浮点寄存器、向量寄存器、媒体寄存器、系统寄存器等。</li></ol><h2 id="存储器组织">存储器组织</h2><h3 id="存储器模型">存储器模型</h3><ol type="1"><li>平展存储模型：存储器是连续的地址空间，每个存储单元存储一个字节并拥有一个线性地址，<code>IA-32</code> 处理器最大支持 <span class="math inline">\(2^{32} - 1\)</span> (4GB) 的地址空间。</li><li>段式存储模型: 存储器由一组独立的地址空间（段）组成，代码、数据、堆栈位于分开的段中，程序利用逻辑地址寻址段中的字节，<code>IA-32</code> 支持 <span class="math inline">\(2^{14}\)</span> 个大小类型各异的段，段的最大容量与平展存储相同，均为 4GB 。</li><li>实地址存储模型: 8086 的存储模型，是段式存储的特例，线性地址空间最大位 1MB ，由最大为 64KB 的多个段组成。</li></ol><h3 id="工作方式">工作方式</h3><h4 id="保护方式protected-mode">保护方式（Protected Mode）</h4><ol type="1"><li><code>IA-32</code>处理器固有的工作状态</li><li>具有强大的段页式存储管理和特权与保护能力</li><li>使用全部32条地址总线，可寻址4GB物理存储器</li><li>使用平展或段式存储模型</li><li>利用虚拟8086方式支持实地址8086软件</li></ol><h4 id="实地址方式real-address-mode">实地址方式（Real Address Mode）</h4><ol type="1"><li>可以进行32位处理的快速8086</li><li>只能寻址1MB物理存储器空间，每个段不超过64KB</li><li>可以使用32位寄存器、32位操作数和32位寻址方式</li><li>只能支持实地址存储模型</li></ol><h4 id="系统管理方式system-management-mode-smm">系统管理方式（System Management Mode, SMM）</h4><ol type="1"><li>用于实现节能和系统安全管理</li><li>保存当前任务后切换到分开的地址空间</li></ol><h3 id="逻辑地址">逻辑地址</h3><p>逻辑地址是程序设计和处理器中使用的相对地址，逻辑地址 = 段基地址:偏移地址，编程使用的逻辑地址会被处理器映射为线性地址，在输出前转换为物理地址。</p><h4 id="基本段">基本段</h4><ol type="1"><li>代码段: 存放指令代码</li><li>数据段: 存放数据</li><li>堆栈段: 堆栈数据</li></ol><h5 id="基本段的逻辑地址">基本段的逻辑地址</h5><ol type="1"><li>代码段: <code>CS</code>:<code>EIP</code></li><li>数据段: <code>DS</code>/<code>FS</code>/<code>GS</code>:取决于寻址方式，由存储器计算得出</li><li>堆栈段: <code>SS</code>:<code>ESP</code></li></ol><h4 id="段选择器">段选择器</h4><p>逻辑地址的段基地址部分由16位的段寄存器确定。段寄存器保存16位的段选择器，段选择器是一种特殊的指针，指向段描述符，段描述符包括段基地址，由段基地址就可以指明存储器中的一个段。</p><p>根据存储模型不同，段寄存器的具体内容也有所不同。</p><h5 id="平展存储模型">平展存储模型</h5><ol type="1"><li>6个段寄存器均指向线性地址空间的0地址</li><li>程序设置2个重叠的段，一个用于代码，一个用于数据和堆栈，CS段寄存器指向代码，其他段寄存器指向数据和堆栈段。</li></ol><h5 id="段式存储模型">段式存储模型</h5><p>段寄存器保存不同的段选择器，指向线性地址空间不同的段，例如下图所示，程序最多可以访问6个段，CS指向代码段，SS指向堆栈段，DS和其余4个段寄存器指向的数据段。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305202025716.png" alt="image.png" /><figcaption aria-hidden="true">image.png</figcaption></figure><h5 id="实地址存储模型">实地址存储模型</h5><p>实地址存储的主存只有 1MB（<span class="math inline">\(2^{20}\)</span>字节），仅使用地址总线的低20位，物理地址范围为 00000H-FFFFFH。实地址存储模型也进行分段处理，但是存在2个限制:</p><ol type="1"><li>每个段最大64KB</li><li>段只能开始于低4位地址全为0的物理地址处，因此实地址的段寄存器可以保存段基地址的高16位</li></ol><h4 id="地址转换">地址转换</h4><h5 id="保护方式的地址转换">保护方式的地址转换</h5><table><thead><tr class="header"><th>存储模型</th><th>转换方式</th></tr></thead><tbody><tr class="odd"><td>平整存储模型</td><td>段基地址为0，偏移地址等于线性地址</td></tr><tr class="even"><td>段式存储模型</td><td>段基地址和偏移地址均为32位</td></tr><tr class="odd"><td></td><td>端基加上线性偏移等于线性地址</td></tr></tbody></table><p>此外，在不使用分页机制时，线性地址与物理地址一一对应，使用分页时，线性地址空间被分成大小一致的块（页），构成虚拟存储器并转换到物理地址空间。</p><h5 id="实地址方式的地址转换">实地址方式的地址转换</h5><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305202125358.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305202126358.png" /></p><h1 id="汇编语言实验混合">汇编语言/实验混合</h1><p>这块照搬书或者 PPT 就有点太无聊了，所以决定混合着上机实验一块复习了。</p><h2 id="masm-模板">masm 模板</h2><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span> <span class="hljs-comment">;该行指令设置使用 586 或更高版本的指令集</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall <span class="hljs-comment">;该行指令设置使用 flat 模型和 stdcall 调用约定</span><br><br><span class="hljs-comment">;这些行指令将相关的库文件包含到程序中，以便使用库中定义的函数和符号。</span><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br><span class="hljs-comment">;下面5行指令声明了一些常用的函数原型</span><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br><br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br><span class="hljs-comment">;在此处可以声明一些变量，类似于高级语言中的 static</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br><span class="hljs-comment">;此处编写主程序</span><br><br><span class="hljs-keyword">push</span> <span class="hljs-number">0</span><span class="hljs-comment">;将0压栈</span><br><span class="hljs-keyword">call</span> ExitProcess；对应return <span class="hljs-number">0</span><br>main ENDP<br>end main<br><br></code></pre></td></tr></table></figure><h2 id="实验二简单分支程序设计">实验二：简单分支程序设计</h2><p>实验目的:</p><ol type="1"><li>掌握算术运算指令</li><li>掌握 <code>cmp</code>, <code>test</code> 以及各类转移指令</li><li>掌握 c 语言关系表达式和逻辑表达式对应的汇编实现</li><li>掌握分支程序设计</li></ol><h3 id="判断输入">1. 判断输入</h3><p>将下面C语言程序的代码片段转换为功能等价的汇编语言代码片段；编写一完整的汇编语言程序验证转换的正确性，其中sinteger（输入的整数） 与sign（输出的信息）均为双字变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span>  (sinteger == <span class="hljs-number">0</span>)<br>sign = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( siteger &gt; <span class="hljs-number">0</span>) <br>sign = <span class="hljs-number">1</span>;  <br><span class="hljs-keyword">else</span> <br>    sign = －<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><h4 id="参考代码">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br><br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>sinteger <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>sign <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span><span class="hljs-comment">;</span><br>string <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">0</span><span class="hljs-comment">;</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br><span class="hljs-keyword">push</span> offset sinteger<br><span class="hljs-keyword">push</span> offset string<br><span class="hljs-keyword">call</span> scanf<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><br><span class="hljs-keyword">cmp</span> sinteger, <span class="hljs-number">0</span><br><span class="hljs-keyword">je</span><span class="hljs-meta">zero</span><br><span class="hljs-keyword">jl</span> negtive<br><span class="hljs-comment">;postive:</span><br><span class="hljs-keyword">mov</span> sign, <span class="hljs-number">1</span><br><span class="hljs-keyword">jmp</span> print<br><span class="hljs-symbol">zero:</span><br><span class="hljs-keyword">mov</span> sign, <span class="hljs-number">0</span><br><span class="hljs-keyword">jmp</span>print<br><span class="hljs-symbol">negtive:</span><br><span class="hljs-keyword">mov</span> sign, -<span class="hljs-number">1</span><br><span class="hljs-symbol">print:</span><br><span class="hljs-keyword">push</span> sign<br><span class="hljs-keyword">push</span> offset string<br><span class="hljs-keyword">call</span> printf<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><br><span class="hljs-keyword">push</span> <span class="hljs-number">0</span><br><span class="hljs-keyword">call</span> ExitProcess<br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><p>感觉这个语法和 <code>SHENZHENG/IO</code> 里面限制20行的汇编也差不多（</p><p>不过里面用来判断的关键词是 <code>teq</code>/<code>tgt</code>/<code>tlt</code>/<code>tcp</code></p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305211048133.png" alt="游戏截图" /><figcaption aria-hidden="true">游戏截图</figcaption></figure><p>稍微解释一下在这个实验中用到的 <code>IA-32</code> <code>masm</code> 指令的用法</p><p>在 <code>.data</code> 数据段我们声明了两个初始化0的用于存储输入数字的双字变量，以及一个存入了格式化字符串的byte数组。</p><p>在代码段，使用 <code>offset/addr</code> 关键字获取偏移并压栈，并使用 call 关键字调用 <code>scanf</code> 函数读入，由于使用 <code>stdcall</code> 调用约定，所以栈指针 esp 上移 <span class="math inline">\(2 \times 4 = 8\)</span> 个字节。</p><p>此处一种更简单的写法是使用 <code>invoke</code> 宏来处理，这个宏的用法会在之后的实验中介绍。</p><p>完成读入后使用 <code>cmp</code> 指令判断其与0的大小关系，并使用条件跳转指令 <code>je</code>(jump if equal), <code>jl</code>(jump if less) 与标签跳转至对应的分支。</p><p>并处理完对应分支的操作后重新跳转回主控制流，对应 <code>jmp print</code> 。</p><p>由于读入和输出的格式化字符串一致，所以此处就复用了，接下来的操作流程和开始读入时一致，故此处就不详细介绍了。</p><h3 id="转换ascii大小写">2.转换ASCII大小写</h3><p>将下面C语言程序的代码片段转换为功能等价的汇编语言代码片段，其中 <code>ch1</code> （输入的字符）与 <code>caps</code> （输出的信息）均为字节变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">if</span> (ch1&gt; =’a’ &amp;&amp; ch1&lt; =’z’)<br>    caps=<span class="hljs-number">0</span>; ch1=upper(ch1);<br><span class="hljs-keyword">if</span> (ch1&gt; =’A’ &amp;&amp; ch1&lt; =’Z’)<br>    caps=<span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><p>提示：小写字母与大写字母的 <code>ASCII</code> 码的差值为 <code>20H</code>，也可以用 <code>ch1 = ch1&amp;0x5f</code></p><h4 id="参考代码-1">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br><br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>ch1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;a&#x27;</span><br>cha <span class="hljs-built_in">byte</span> <span class="hljs-number">95</span><br>caps <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;0&#x27;</span><br>infstring <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;%c&quot;</span>, <span class="hljs-number">0</span><br>outfstring <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;cha=&#x27;%c&#x27; cap=&#x27;%c&#x27;&quot;</span>, <span class="hljs-number">0</span><br>errfstring <span class="hljs-built_in">db</span> <span class="hljs-string">&quot;error&quot;</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br>invoke scanf, addr infstring, addr ch1<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, ch1<br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;a&#x27;</span><br><span class="hljs-keyword">jb</span> captial<br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;z&#x27;</span><br><span class="hljs-keyword">ja</span> captial<br><span class="hljs-comment">;small:</span><br><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">al</span>, cha<br><span class="hljs-keyword">mov</span> ch1, <span class="hljs-built_in">al</span><br><span class="hljs-keyword">jmp</span> print<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">captial:</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;A&#x27;</span><br><span class="hljs-keyword">jb</span> error<br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>, <span class="hljs-string">&#x27;Z&#x27;</span><br><span class="hljs-keyword">ja</span> error<br><br><span class="hljs-keyword">mov</span> caps, <span class="hljs-string">&#x27;1&#x27;</span><br><span class="hljs-symbol">print:</span><br>invoke printf,addr outfstring , ch1, caps<br><span class="hljs-keyword">ret</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">error:</span><br>invoke printf,addr errfstring<br><span class="hljs-keyword">ret</span><br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><p>这一段代码中使用 invoke 宏来简化手动管理堆栈平衡的操作，并且使用了 ret 来返回控制权，同时为了处理输入字符可能存在的非法情况，加入了错误处理部分。</p><h3 id="以内的偶数求和">3. 100以内的偶数求和</h3><p>将下面C语言程序的代码片段转换为功能等价的汇编语言代码片段；编写一完整的汇编语言程序验证转换的正确性，其中 <code>sum</code> 与 <code>i</code> 均为双字变量。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs c">sum=<span class="hljs-number">0</span>; <br><span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;=<span class="hljs-number">100</span>; i++)    <br>    <span class="hljs-keyword">if</span>(i%<span class="hljs-number">2</span>==<span class="hljs-number">0</span>)<br>        sum=sum+i;<br></code></pre></td></tr></table></figure><p>提示：可采用 <code>div</code> 指令求余数</p><h4 id="参考代码-2">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>fstr <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;sum = %d&#x27;</span>,<span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span><span class="hljs-comment">;i</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0</span><span class="hljs-comment">;sum</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0</span><span class="hljs-comment">;temp</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_loop:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">100</span><br><span class="hljs-keyword">ja</span> _end<br><br><span class="hljs-keyword">and</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jnz</span> _no_add<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-symbol">_no_add:</span><br><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jmp</span> _<span class="hljs-keyword">loop</span><br><span class="hljs-symbol">_end:</span><br><br>invoke printf, addr fstr, <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">ret</span><br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><p>此处采用了一个 trick 来判断奇偶性，对于一个二进制原码整数来说，其奇偶性取决于其 0 位是否为 0，即结尾是 0 的必然是偶数，否则为奇数。</p><p>所以 <code>and ecx, 1</code> 如果此时 <code>ecx</code> 中结果为 1，说明其必然为奇数，不需要相加。</p><h3 id="以内的正数求和">4. 100以内的正数求和</h3><p>采用无条件 <code>jmp</code> 和条件转移 <code>jcc</code> 指令构造 <code>while</code> 或 <code>do while</code> 循环结构（不得使用 <code>loop</code> 指令），完成下面的求和任务并输出 <code>sum</code> 和 <code>n</code> (变量为双字) （实际上是条件控制的循环） <span class="math display">\[sum=\sum_{i=1}^{100}i \]</span> 思考题：假设 <code>sum</code> 为双字无符号整数，在 <code>sum</code> 不溢出的情况下求出 <code>n</code> 的最大值；并输出此时的 <code>sum</code> 和 <code>n</code> 的值。</p><h4 id="参考代码-3">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">﻿.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>fstr <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;sum = %d&#x27;</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span> <span class="hljs-comment">; i</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">0</span> <span class="hljs-comment">; sum</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_loop:</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">100</span><br><span class="hljs-keyword">ja</span> _end<br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span><br><span class="hljs-keyword">jmp</span> _<span class="hljs-keyword">loop</span><br><span class="hljs-symbol">_end:</span><br><br>invokeprintf, addr fstr, <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">ret</span><br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><h4 id="思考题回答">思考题回答</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> max = <span class="hljs-number">2</span>**<span class="hljs-number">32</span> -<span class="hljs-number">1</span><br><span class="hljs-keyword">const</span> <span class="hljs-title function_">f</span> = (<span class="hljs-params">n</span>) =&gt; (n * (n+<span class="hljs-number">1</span>)) /<span class="hljs-number">2.0</span><br><span class="hljs-keyword">let</span> n = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">while</span>(n++)&#123;<br>    <span class="hljs-keyword">if</span>(<span class="hljs-title function_">f</span>(n) &gt; max) &#123;<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;n = &quot;</span>, n)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;sum = &quot;</span>, <span class="hljs-title function_">f</span>(n))<br></code></pre></td></tr></table></figure><p>使用 <code>node</code> 或者浏览器控制台运行即可，答案是 <code>n = 92682, sum = 4295022903</code></p><h3 id="三数排序">5. 三数排序</h3><p>从键盘上输入3个有符号的双字整数，编写一完整的程序按照又大到小的顺序输出这3个数。</p><p>提示：采用 <code>xchg</code> 指令交换两个变量的值。</p><h4 id="参考代码-4">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>format <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;%d %d %d&#x27;</span>, <span class="hljs-number">0</span><br>_a <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span><br>_b <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span><br>_c <span class="hljs-built_in">dd</span> <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br>invoke scanf, offset format, addr _a, addr _b, addr _c<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, _a<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, _b<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, _c<br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">jnl</span> l1<br><span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-symbol">l1:</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">jnl</span> l2<br><span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">l2:</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">jnl</span> l3<br><span class="hljs-keyword">xchg</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">l3:</span><br><br>invoke printf, offset format, <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">ecx</span><br>invoke ExitProcess,<span class="hljs-number">0</span><br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><h3 id="判断闰年">6. 判断闰年</h3><p>输入年份并判断其是否是闰年，闰年需要满足以下条件中的一个：</p><ol type="1"><li>该年份能被 4 整除同时不能被 100 整除；</li><li>该年份能被400整除。</li></ol><p>提示：可采用 <code>div</code> 指令求余数</p><h4 id="参考代码-5">参考代码</h4><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelib kernel32<span class="hljs-number">.</span>lib<br>includelib ucrt<span class="hljs-number">.</span>lib<br>includelib legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf PROTO C : vararg<br>_getch    PROTO C : vararg         <br>_kbhit    PROTO C : vararg<br><span class="hljs-comment">;include temp.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>fistr <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">0</span><br>fostr1 <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;is leep year&#x27;</span>,<span class="hljs-number">0</span><br>fostr2 <span class="hljs-built_in">db</span> <span class="hljs-string">&#x27;is not leep year&#x27;</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main PROC<br><span class="hljs-comment">;main:</span><br><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br><br><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>], <span class="hljs-number">0</span><span class="hljs-comment">;栈上分配int, 初始化为0</span><br><span class="hljs-keyword">lea</span><span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br><br>invoke scanf, addr fistr, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span><span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">400</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jz</span> is_leap<span class="hljs-comment">;year mod 400 == 0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> not_leap<span class="hljs-comment">;year mod 4 == 0</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">100</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> is_leap<span class="hljs-comment">;year mod 100 != 0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">not_leap:</span><br>invoke printf,addr fostr2<br><span class="hljs-keyword">jmp</span> _end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">is_leap:</span><br>invoke printf,addr fostr1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_end:</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">ret</span><br>main ENDP<br>end main<br></code></pre></td></tr></table></figure><p>此处代码的分析使用语言模型生成，参考 <code>prompt</code> 如下 <figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs armasm">逐行分析下列 IA-<span class="hljs-number">32</span> masm 代码中 <span class="hljs-meta">.code</span> 段的意图<br><span class="hljs-comment">// 代码省略</span><br></code></pre></td></tr></table></figure></p><h5 id="分析">分析</h5><p>该汇编代码段中的<code>.code</code>段是用于定义程序的主要代码逻辑和流程。下面逐行分析该代码段的意图：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.code</span><br>main PROC<br></code></pre></td></tr></table></figure><p>开始定义一个名为<code>main</code>的过程（Procedure）。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br></code></pre></td></tr></table></figure><p>保存旧的基址寄存器值并将当前栈指针赋值给基址寄存器，创建一个新的堆栈帧。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>], <span class="hljs-number">0</span><br><span class="hljs-keyword">lea</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>在堆栈上分配8字节的空间，并将该空间的第一个双字（32位整数）初始化为0。然后，将<code>eax</code>寄存器设置为指向这个双字的地址。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">invoke scanf, addr fistr, <span class="hljs-built_in">eax</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span>-<span class="hljs-number">8</span>]<br></code></pre></td></tr></table></figure><p>调用<code>scanf</code>函数，从用户输入中读取一个整数，并将其存储到之前分配的空间中。然后，将<code>ecx</code>寄存器设置为该整数的值。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">400</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jz</span> is_leap<br></code></pre></td></tr></table></figure><p>将<code>eax</code>寄存器设置为<code>ecx</code>的值，然后将<code>ebx</code>寄存器设置为400，执行带符号除法指令<code>idiv</code>，将<code>eax</code>寄存器中的值除以<code>ebx</code>寄存器中的值。将得到的余数存储在<code>edx</code>寄存器中，然后将<code>edx</code>与0进行比较。如果相等（余数为0），则跳转到<code>is_leap</code>标签处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">4</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> not_leap<br></code></pre></td></tr></table></figure><p>将<code>eax</code>寄存器设置为<code>ecx</code>的值，然后将<code>ebx</code>寄存器设置为4，执行带符号除法指令<code>idiv</code>，将<code>eax</code>寄存器中的值除以<code>ebx</code>寄存器中的值。将得到的余数存储在<code>edx</code>寄存器中，然后将<code>edx</code>与0进行比较。如果不相等（余数不为0），则跳转到<code>not_leap</code>标签处。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ecx</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">100</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> is_leap<br></code></pre></td></tr></table></figure><p>将<code>eax</code>寄存器设置为<code>ecx</code>的值，然后将<code>ebx</code>寄存器设置为100，执行带符号除法指令<code>idiv</code>，将<code>eax</code>寄存器中的值除以<code>ebx</code>寄存器中的值。将得到的余数存储在<code>edx</code>寄存器中，然后将<code>edx</code>与0进行比较。如果不相等（余数不为0），则跳转到<code>is_leap</code>标签处</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-symbol">not_leap:</span><br>invoke printf, addr fostr2<br><span class="hljs-keyword">jmp</span> _end<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">is_leap:</span><br>invoke printf, addr fostr1<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_end:</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br><span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">ret</span><br></code></pre></td></tr></table></figure><p>在<code>not_leap</code>标签处，调用<code>printf</code>函数，打印字符串<code>fostr2</code>。然后跳转到<code>_end</code>标签处。在<code>is_leap</code>标签处，调用<code>printf</code>函数，打印字符串<code>fostr1</code>。然后继续执行到<code>_end</code>标签处。</p><p>在<code>_end</code>标签处，释放在堆栈上分配的8字节空间，恢复堆栈指针，并将旧的基址寄存器值恢复。最后，将<code>eax</code>寄存器设置为0并返回。</p><p>整个代码段的目的是读取用户输入的一个整数，然后判断该整数是否为闰年，并根据判断结果打印相应的字符串。</p><h3 id="实验三循环程序设计实验">实验三：循环程序设计实验</h3><h4 id="的闰年数量">1. 2012-2100的闰年数量</h4><h5 id="参考代码-6">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelibmsvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf  proto C: vararg<br><br><span class="hljs-comment">;include vcIO.inc</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>Lyear <span class="hljs-built_in">dword</span> <span class="hljs-number">25</span> dup(<span class="hljs-number">0</span>) <span class="hljs-comment">;结果数组</span><br>msg <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;Leap year is follow:&#x27;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span><br>format <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d&#x27;</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main Proc<br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-built_in">ecx</span> <span class="hljs-comment">;将寄存器ECX清零，用于计数闰年的个数</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">2012</span> <span class="hljs-comment">;将寄存器ESI的值设置为2012，即开始年份</span><br><span class="hljs-keyword">jmp</span> testing<br><span class="hljs-symbol">body:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">esi</span> <span class="hljs-comment">;将寄存器EAX的值设置为ESI，即当前年份</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">4</span> <span class="hljs-comment">;将寄存器EBX的值设置为4，用于进行除法运算</span><br><span class="hljs-keyword">cdq</span> <br><span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> next <span class="hljs-comment">;如果 year % 4 != 0，则跳转到标签`next`处</span><br>    <span class="hljs-comment">;此处已满足被4整除</span><br>    <br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">esi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">100</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">je</span> next <span class="hljs-comment">;如果 year % 4 == 100，则跳转至标签`next`处</span><br><br>    <span class="hljs-comment">;此处已满足被4整除且不被100整除</span><br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> Lyear[<span class="hljs-built_in">ecx</span>*<span class="hljs-number">4</span>],<span class="hljs-built_in">esi</span> <br><span class="hljs-comment">;保存结果，乘4因为32位整数四字节大小</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span> <span class="hljs-comment">;增加计数</span><br><span class="hljs-keyword">jmp</span> over<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">next:</span> <span class="hljs-comment">;此处判断是否被400整除</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">esi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>,<span class="hljs-number">400</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">div</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>,<span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> over<br><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> Lyear[<span class="hljs-built_in">ecx</span>*<span class="hljs-number">4</span>],<span class="hljs-built_in">esi</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol">over:</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">;增加年份计数</span><br><span class="hljs-symbol">testing:</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">2100</span><br><span class="hljs-keyword">jl</span> body<br><br><span class="hljs-keyword">pushad</span> <span class="hljs-comment">;保护寄存器现场</span><br>invoke printf,offset msg<br><span class="hljs-keyword">popad</span><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">esi</span><br><span class="hljs-symbol">again:</span><br><span class="hljs-keyword">pushad</span><br>invoke printf,offset format,<span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> Lyear[<span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span>]<br><span class="hljs-keyword">popad</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">loop</span> again<br><br>invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br></code></pre></td></tr></table></figure><h4 id="回文串判断">2. 回文串判断</h4><p>“回文串”是一个正读和反读都一样的字符串，比如“eye”、“level”、“noon”等。请写一个程序测试一字符串是否是“回文”， 是“回文”则显示“Y”。</p><p>提示：</p><ol type="1"><li>合理分配寄存器: <code>left = esi, right = edi, flag = al = 'Y'</code></li><li>采用相对寻址处理数组。</li></ol><h5 id="参考代码-7">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><span class="hljs-meta"> </span><br><span class="hljs-meta">.386</span><br><span class="hljs-meta">.model</span> flat,stdcall<br> <br>ExitProcess PROTO,<br><span class="hljs-symbol">dwExitCode:</span><span class="hljs-built_in">DWORD</span><br> <br>printf    PROTO C : <span class="hljs-built_in">dword</span>,:vararg<br>scanf    PROTO C : <span class="hljs-built_in">dword</span>,:vararg<br><br><span class="hljs-comment">;INCLUDE vcIO.inc</span><br><span class="hljs-meta">.data</span><br>    array <span class="hljs-built_in">BYTE</span> <span class="hljs-string">&quot;lwasdffdsawl&quot;</span>,<span class="hljs-number">0</span><br>    str_error <span class="hljs-built_in">BYTE</span> <span class="hljs-string">&quot;该字符串不是回文串&quot;</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0</span><br>    str_ok <span class="hljs-built_in">BYTE</span> <span class="hljs-string">&quot;该字符串是回文串&quot;</span>,<span class="hljs-number">0ah</span>,<span class="hljs-number">0</span><br><span class="hljs-meta">.code</span><br>main PROC<br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">esi</span> <span class="hljs-comment">;esi为头指针</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, LENGTHOF array - <span class="hljs-number">2</span> <span class="hljs-comment">;edi为尾指针</span><br>    <span class="hljs-comment">;数组索引从0 ~ array-1，其中最后一位为 &#x27;\0&#x27;</span><br>    <span class="hljs-comment">;故实际最后一位的索引为 array-2</span><br>    <br>    <span class="hljs-keyword">jmp</span> TESTING<br><span class="hljs-symbol">FORLOOP:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>,array[<span class="hljs-built_in">esi</span>*<span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bl</span>,array[<span class="hljs-built_in">edi</span>*<span class="hljs-number">1</span>]<br>    <br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">al</span>,<span class="hljs-built_in">bl</span><br>    <span class="hljs-keyword">jne</span> EXIT <span class="hljs-comment">;如果头尾指针元素不同则不是回文串</span><br>    <br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">edi</span> <br>    <span class="hljs-keyword">jmp</span> TESTING<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">EXIT:</span><br>    invoke printf, OFFSET str_error<br>    <span class="hljs-keyword">jmp</span> ENDLOOP<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">TESTING:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>,<span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">jbe</span> FORLOOP <span class="hljs-comment">;esi&lt;=edi 时继续循环</span><br><br>    invoke printf, OFFSET str_ok<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">ENDLOOP:</span><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main ENDP<br>END main<br></code></pre></td></tr></table></figure><h4 id="字符统计">3. 字符统计</h4><p>编程写一个完整的程序统计字符串msg中的空格的个数与小写字母的个数，并分别将它们存入space单元与char单元中并输出。</p><h5 id="参考代码-8">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat, stdcall<br><br>includelib msvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span> <span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf proto C: vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    msg <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;hello, m a s m!&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br>    space <span class="hljs-built_in">dword</span> ?<br>    lowercase <span class="hljs-built_in">dword</span> ?<br>    frmStr <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;space num = %d, lowercase num = %d&quot;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, lengthof msg   <br>    <span class="hljs-comment">; 将字符串 msg 的长度存储在 ECX 寄存器中</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, offset msg     <br>    <span class="hljs-comment">; 将字符串 msg 的起始地址存储在 ESI 寄存器中</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span>            <br>    <span class="hljs-comment">; 将 EAX 寄存器清零，用于计数空格字符的数量</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">eax</span>            <br>    <span class="hljs-comment">; 将 EBX 寄存器清零，用于计数小写字母的数量</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">again:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dl</span>, [<span class="hljs-built_in">esi</span>]           <span class="hljs-comment">; 将当前字符读取到 DL 寄存器中</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">dl</span>, <span class="hljs-string">&#x27; &#x27;</span>             <span class="hljs-comment">; 比较当前字符与空格字符 &#x27; &#x27; 是否相等</span><br>    <span class="hljs-keyword">jnz</span> letter              <span class="hljs-comment">; 如果不相等，跳转到 letter 标签继续执行</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span>                 <span class="hljs-comment">; 空格字符计数器加 1</span><br><span class="hljs-symbol">letter:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">dl</span>, <span class="hljs-string">&#x27;a&#x27;</span>             <span class="hljs-comment">; 比较当前字符与小写字母 &#x27;a&#x27; 是否相等</span><br>    <span class="hljs-keyword">jb</span> next                 <span class="hljs-comment">; 如果当前字符小于 &#x27;a&#x27;，跳转到 next 标签</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">dl</span>, <span class="hljs-string">&#x27;z&#x27;</span>             <span class="hljs-comment">; 比较当前字符与小写字母 &#x27;z&#x27; 是否相等</span><br>    <span class="hljs-keyword">jg</span> next                 <span class="hljs-comment">; 如果当前字符大于 &#x27;z&#x27;，跳转到 next 标签</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ebx</span>                 <span class="hljs-comment">; 小写字母计数器加 1</span><br><span class="hljs-symbol">next:</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span>                 <span class="hljs-comment">; 字符串指针增加 1</span><br>    <span class="hljs-keyword">loop</span> again              <span class="hljs-comment">; 继续循环，直到 ECX 寄存器减为零</span><br><br>    <span class="hljs-keyword">pushad</span>                  <span class="hljs-comment">; 保存所有通用寄存器的值</span><br>    invoke printf, offset frmStr, <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span> <br>    <span class="hljs-comment">; 调用 printf 函数，输出格式化字符串，并传递计数器的值</span><br>    <br>    <span class="hljs-keyword">popad</span>                   <span class="hljs-comment">; 恢复之前保存的通用寄存器的值</span><br>    invoke ExitProcess, <span class="hljs-number">0</span>   <br>main endp<br>end main<br></code></pre></td></tr></table></figure><h4 id="求数组最大值与最小值">4. 求数组最大值与最小值</h4><p>编程写一个完整的程序,求数组 <code>array[12, 4, 168, 122, -33, 56, 78, 99, 345, 66, -5]</code> 中的最大值与最小值，并将它们分别存入 <code>max</code> 和 <code>min</code> 单元中。</p><h5 id="参考代码-9">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat, stdcall<br><br>includelib msvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode: <span class="hljs-built_in">DWORD</span>     <span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf proto C: vararg<br><br><span class="hljs-comment">; include vcIO.inc</span><br>_getch PROTO C: <span class="hljs-built_in">DWORD</span>, : vararg<br><span class="hljs-meta">.data</span><br>    array <span class="hljs-built_in">dword</span> <span class="hljs-number">12</span>, <span class="hljs-number">4</span>, <span class="hljs-number">168</span>, <span class="hljs-number">122</span>, -<span class="hljs-number">33</span>, <span class="hljs-number">56</span>, <span class="hljs-number">78</span>, <span class="hljs-number">99</span>, <span class="hljs-number">345</span>, <span class="hljs-number">66</span>, -<span class="hljs-number">5</span><br>    fstr1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;min=%d&#x27;</span>, <span class="hljs-number">0ah</span>, <span class="hljs-number">0</span><br>    fstr2 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;max=%d&#x27;</span>, <span class="hljs-number">0ah</span>, <span class="hljs-number">0</span><br><span class="hljs-meta">.code</span><br>main proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, offset array <span class="hljs-comment">;索引</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, lengthof array <span class="hljs-comment">;计数器</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">edx</span>] <span class="hljs-comment">;min</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">edx</span>] <span class="hljs-comment">;max</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">esi</span> <span class="hljs-comment">;temp变量</span><br><span class="hljs-symbol">    </span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    _loop:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, [<span class="hljs-built_in">edx</span>]<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    check_min:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">jle</span> check_max<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">esi</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    check_max:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">jge</span> check_end<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">esi</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    check_end:</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">loop</span> _<span class="hljs-keyword">loop</span><br><br><br>    invoke printf, addr fstr1, <span class="hljs-built_in">eax</span><br>    invoke printf, addr fstr2, <span class="hljs-built_in">ebx</span><br><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br><br></code></pre></td></tr></table></figure><h4 id="寻找回文数">5. 寻找回文数</h4><p>求10到10000之间所有回文数并输出。要求每行输出10个数。</p><h5 id="参考代码-10">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat,stdcall<br><br>includelibmsvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span><span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf  proto C: vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>msg1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d&#x27;</span>,<span class="hljs-number">9</span>,<span class="hljs-number">0</span><br>msg2 <span class="hljs-built_in">byte</span> <span class="hljs-number">10</span>,<span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main Proc<br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">10</span> <span class="hljs-comment">; esi 为起始检查值</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>,<span class="hljs-number">0</span><span class="hljs-comment">; edi 为输出个数计数器</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">body:</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>,<span class="hljs-number">0</span> <span class="hljs-comment">; ecx 存放反转后的当前 esi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>,<span class="hljs-built_in">esi</span> <br><span class="hljs-symbol"></span><br><span class="hljs-symbol">reverse:</span><br><span class="hljs-keyword">imul</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">cdq</span><br><span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-keyword">add</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">edx</span><br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span><br><span class="hljs-keyword">jne</span> reverse<br><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">esi</span> <br><span class="hljs-keyword">jne</span> loop_check<br><br>invoke printf,addr msg1, <span class="hljs-built_in">ecx</span> <span class="hljs-comment">;打印回文数</span><br><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span><br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edi</span>, <span class="hljs-number">10</span><br><span class="hljs-keyword">jne</span> loop_check<br><br>invoke printf, addr msg2 <span class="hljs-comment">;打印换行符</span><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">edi</span> <span class="hljs-comment">;edi 置0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">loop_check:</span><br><span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span> <br><span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>,<span class="hljs-number">10000</span> <br><span class="hljs-keyword">jl</span> body <br><br>invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br></code></pre></td></tr></table></figure><h4 id="剔除空格">6. 剔除空格</h4><p>有一个首地址为 <code>string</code> 的字符串，剔除 <code>string</code>中所有的空格字符。请从字符串最后一个字符开始逐个向前判断、并进行处理。</p><h5 id="参考代码-11">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat, stdcall<br><br>includelib msvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><span class="hljs-meta"></span><br><span class="hljs-meta">.386</span><br><span class="hljs-meta">.model</span> flat, stdcall<br><br>ExitProcess PROTO,<br><span class="hljs-symbol">dwExitCode:</span> <span class="hljs-built_in">DWORD</span><br><br>printf PROTO C: <span class="hljs-built_in">DWORD</span>, : vararg<br>scanf PROTO C: <span class="hljs-built_in">DWORD</span>, : vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    string <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;Dubi Dubi Duba Dubi Dubi Duba Perry&#x27;</span>, <span class="hljs-number">0</span><br>    format <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%s&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main Proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, lengthof string - <span class="hljs-number">1</span> <span class="hljs-comment">; esi == scanP</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">esi</span> <span class="hljs-comment">; edi == tailP</span><br>    <span class="hljs-keyword">jmp</span> body_check<br><span class="hljs-symbol">body:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> string[<span class="hljs-built_in">esi</span>], <span class="hljs-string">&#x27; &#x27;</span><br>    <span class="hljs-keyword">jne</span> _continue<br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">esi</span> <span class="hljs-comment">; ebx == moveP</span><br>    <span class="hljs-keyword">jmp</span> move_check<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_move:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">al</span>, <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> string[<span class="hljs-built_in">ebx</span> + <span class="hljs-number">1</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">byte</span> <span class="hljs-built_in">ptr</span> string[<span class="hljs-built_in">ebx</span>], <span class="hljs-built_in">al</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ebx</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">move_check:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">edi</span><br>    <span class="hljs-keyword">jl</span> _move<br><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">edi</span><br><span class="hljs-symbol">_continue:</span><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">esi</span><br><span class="hljs-symbol">body_check:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br>    <span class="hljs-keyword">jge</span> body<br><br>    invoke printf, offset format, offset string<br><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br><br></code></pre></td></tr></table></figure><p>这段代码简单来说就是从后往前寻找空白字符，如果找到了，将后续所有往前移动一步然后接着找空白字符，直至找到字符串的头部。</p><h4 id="素数筛">7. 素数筛</h4><p>求出2～1000之间的所有素数，并将它们存入 <code>Prime</code> 数组中，素数的个数存入变量 <code>Pcounter</code> 中。要求每行输出10个数。</p><h5 id="参考代码-12">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat, stdcall<br><br>includelib msvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode: <span class="hljs-built_in">DWORD</span> <span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf proto C: vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    fstr1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d &#x27;</span>, <span class="hljs-number">0</span><br>    fstr2 <span class="hljs-built_in">byte</span> <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br>    fstr3 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;prime number count: %d&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br>    prime <span class="hljs-built_in">dword</span> <span class="hljs-number">2</span>, <span class="hljs-number">3</span> , <span class="hljs-number">0</span> dup(<span class="hljs-number">1000</span>)<br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main Proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">4</span> <span class="hljs-comment">;start number</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">2</span> <span class="hljs-comment">;prime counter</span><br>    <span class="hljs-keyword">jmp</span> body_check<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    body:</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edi</span>, <span class="hljs-number">0</span> <span class="hljs-comment">;素数筛索引</span><br><span class="hljs-symbol">  </span><br><span class="hljs-symbol">    sieve:</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">esi</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> prime[<span class="hljs-built_in">edi</span>*<span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">cdq</span><br>        <span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br>        <span class="hljs-keyword">jz</span> _continue <span class="hljs-comment">;可被整除，跳至_continue</span><br><br>        <br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">edi</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">edi</span>, <span class="hljs-built_in">ecx</span><br>        <span class="hljs-keyword">jl</span> sieve<br><br>        <span class="hljs-comment">; 未被筛除，将其加入素数筛中</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> prime[<span class="hljs-built_in">ecx</span>*<span class="hljs-number">4</span>], <span class="hljs-built_in">esi</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    _continue:</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span> <span class="hljs-comment">;移动至下一个待筛数字</span><br><span class="hljs-symbol">    body_check:</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">1000</span><br>        <span class="hljs-keyword">jl</span> body<br><br>    <br>    <br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">0</span> <span class="hljs-comment">;prime计数器</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span> <span class="hljs-comment">;格式化计数器</span><br><span class="hljs-symbol">    print:</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> prime[<span class="hljs-built_in">eax</span>*<span class="hljs-number">4</span>]<br><br>        <span class="hljs-keyword">pushad</span><br>        invoke printf, addr fstr1, <span class="hljs-built_in">ebx</span><br>        <span class="hljs-keyword">popad</span><br><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">10</span><br><br>        <span class="hljs-keyword">jne</span> _continue_print<br><br>        <span class="hljs-keyword">pushad</span><br>        invoke printf, addr fstr2<br>        <span class="hljs-keyword">popad</span><br>        <br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">        _continue_print:</span><br>    <span class="hljs-keyword">loop</span> print<br><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br><br></code></pre></td></tr></table></figure><h3 id="实验四子程序与操作系统功能调用">实验四：子程序与操作系统功能调用</h3><h4 id="递归阶乘">1. 递归阶乘</h4><p>编写一个求 <span class="math inline">\(n!\)</span> 的子程序，利用它求 <span class="math inline">\(1!+2! +3! +4! +5! +6! +7! +8!\)</span> 的和（46233）并输出。</p><h5 id="参考代码-13">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><span class="hljs-meta"></span><br><span class="hljs-meta">.386</span><br><span class="hljs-meta">.model</span> flat, stdcall<br><br>ExitProcess PROTO,<br><span class="hljs-symbol">dwExitCode:</span> <span class="hljs-built_in">DWORD</span><br><br>printf PROTO C: <span class="hljs-built_in">DWORD</span>, : VARARG<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    msg1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;f(x)=x!&quot;</span>,<span class="hljs-number">10</span>,<span class="hljs-number">0</span><br>    msg2 <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;f(%d)=%d&quot;</span>,<span class="hljs-number">10</span>, <span class="hljs-number">0</span><br>    msg3 <span class="hljs-built_in">byte</span> <span class="hljs-string">&quot;sum=%d&quot;</span>, <span class="hljs-number">10</span>,<span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br><br>main PROC<br>    invoke printf, addr msg1<br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    fac:</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">call</span> Factorial<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">eax</span><br><br>    <span class="hljs-keyword">pushad</span><br>    invoke printf, addr msg2, <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">popad</span><br><br><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">8</span><br>    <span class="hljs-keyword">jle</span> fac<br><br>    invoke printf, addr msg3, <span class="hljs-built_in">edx</span><br><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main ENDP<br><br>Factorial PROC<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span><br>    <span class="hljs-keyword">sub</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span>     <span class="hljs-comment">; 为局部变量分配4字节的栈空间</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>] <span class="hljs-comment">; 获取参数n的值</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">1</span><br>    <span class="hljs-keyword">jbe</span> Return      <span class="hljs-comment">; 如果n小于等于1，直接返回1</span><br><br>    <span class="hljs-keyword">dec</span> <span class="hljs-built_in">eax</span>         <span class="hljs-comment">; 将n减1</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span>        <span class="hljs-comment">; 将n-1作为参数压入栈中</span><br>    <span class="hljs-keyword">call</span> Factorial  <span class="hljs-comment">; 递归调用阶乘子过程</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">4</span>      <span class="hljs-comment">; 清除栈中的参数</span><br><br>    <span class="hljs-keyword">imul</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>] <span class="hljs-comment">; 将结果乘以n，存储在eax中</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">Return:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-number">4</span>           <span class="hljs-comment">; 从过程返回并清除栈中的参数</span><br>Factorial ENDP<br><br>END main<br></code></pre></td></tr></table></figure><h4 id="斐波那契数列">2. 斐波那契数列</h4><p>Fibonacci numbers的定义： <span class="math display">\[f_1=1,\ f_2=1,\ f_n = f_{n-1}+f_{n-2}\ when \ n\ge3 \]</span> 编程输出 Fibonacci numbers 的前20项。 思考题：在不产生溢出的情况下 <span class="math inline">\(n\)</span> 的最大值是多少？</p><h5 id="参考代码-14">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><span class="hljs-meta"></span><br><span class="hljs-meta">.386</span><br><span class="hljs-meta">.model</span> flat, stdcall<br><br>ExitProcess PROTO,<br><span class="hljs-symbol">    dwExitCode:</span><span class="hljs-built_in">DWORD</span><br><br>printf PROTO C : <span class="hljs-built_in">dword</span>, :vararg<br>scanf PROTO C : <span class="hljs-built_in">dword</span>, :vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>    array <span class="hljs-built_in">dword</span> <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">18</span> dup(<span class="hljs-number">0</span>)<br>    format <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d&#x27;</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main Proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">2</span><br>    <span class="hljs-keyword">jmp</span> check<br><span class="hljs-symbol"></span><br><span class="hljs-symbol">body:</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> array[<span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span> - <span class="hljs-number">4</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> array[<span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span> - <span class="hljs-number">8</span>]<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> array[<span class="hljs-built_in">esi</span>*<span class="hljs-number">4</span>], <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">check:</span><br>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">20</span><br>    <span class="hljs-keyword">jl</span> body<br><br><br><span class="hljs-keyword">xor</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">esi</span><br><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-number">20</span><br><span class="hljs-symbol">print:</span><br>    <span class="hljs-keyword">pushad</span><br>    invoke printf, offset format, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> array[<span class="hljs-built_in">esi</span>]<br>    <span class="hljs-keyword">popad</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">4</span>    <br><span class="hljs-keyword">loop</span> print<br><br>invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br>end main<br><br></code></pre></td></tr></table></figure><h5 id="思考题答案">思考题答案</h5><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs js"><span class="hljs-keyword">const</span> max = <span class="hljs-number">2</span>**<span class="hljs-number">32</span> - <span class="hljs-number">1</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-title class_">Array</span>(<span class="hljs-number">100</span>).<span class="hljs-title function_">fill</span>(<span class="hljs-number">1</span>)<br>s[<span class="hljs-number">0</span>]=<span class="hljs-number">0</span><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">3</span>;;i++)&#123;<br>    s[i]=s[i-<span class="hljs-number">1</span>]+s[i-<span class="hljs-number">2</span>]<br>    <span class="hljs-keyword">if</span>(s[i] &gt; max) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;i=&quot;</span>, i - <span class="hljs-number">1</span>)<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;max=&quot;</span>, s[i -<span class="hljs-number">1</span>])<br>        <span class="hljs-keyword">break</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="math display">\[i = 47,max = 2971215073\]</span></p><h4 id="欧几里得算法">3. 欧几里得算法</h4><p>编程写一个名为 <code>Gcd</code> 的求两个数最大公约数子程序，主子程序间的参数传递通过堆栈完成。调用 <code>Gcd</code> 子程序求出三个双自变量：<code>dvar1</code>、<code>dvar2</code> 与 <code>dvar3</code> 的最大公约数并输出。</p><p>提示：<span class="math inline">\(result=gcd(gcd(dvar1,dvar2), dvar3)\)</span></p><h5 id="参考代码-15">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.586</span><br><span class="hljs-meta">.MODEL</span> flat, stdcall<br><br>includelib msvcrt<span class="hljs-number">.</span>lib<br><br>INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><br>ExitProcess PROTO, dwExitCode:<span class="hljs-built_in">DWORD</span> <span class="hljs-comment">; return code</span><br>printf proto C: vararg<br>scanf proto C: vararg<br><br><span class="hljs-comment">;include vcIO.inc</span><br><span class="hljs-meta">.data</span><br>    prompt <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;请输入三个整数（以空格分隔）：&#x27;</span>, <span class="hljs-number">0</span><br>    fmt1 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d %d %d&#x27;</span>, <span class="hljs-number">0</span><br>    fmt2 <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;最大公约数：%d&#x27;</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">13</span>, <span class="hljs-number">10</span>, <span class="hljs-number">0</span><br>    dvar1 <span class="hljs-built_in">dword</span> ?<br>    dvar2 <span class="hljs-built_in">dword</span> ?<br>    dvar3 <span class="hljs-built_in">dword</span> ?<br>    res <span class="hljs-built_in">dword</span> ?<br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br>main proc<br><br>    <br>    invoke printf, offset prompt<br>    invoke scanf, offset fmt1, offset dvar1, offset dvar2, offset dvar3<br>    <br>    <span class="hljs-keyword">push</span> dvar1<br>    <span class="hljs-keyword">push</span> dvar2<br>    <span class="hljs-keyword">call</span> gcd <span class="hljs-comment">; 堆栈传参，结果保存在 EAX</span><br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">push</span> dvar3<br>    <span class="hljs-keyword">call</span> gcd<br>    <span class="hljs-keyword">add</span> <span class="hljs-built_in">esp</span>, <span class="hljs-number">8</span><br>    <span class="hljs-keyword">mov</span> res, <span class="hljs-built_in">eax</span><br>    <span class="hljs-keyword">pushad</span><br>    invoke printf, offset fmt2, res<br>    <span class="hljs-keyword">popad</span><br>    <br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br><br>gcd proc<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span> <span class="hljs-comment">; 保存旧栈帧，建立新栈帧</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">12</span>]<br><span class="hljs-meta"></span><br><span class="hljs-meta">    .if</span> <span class="hljs-built_in">eax</span> &lt; <span class="hljs-built_in">ebx</span><br>        <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-meta">    .endif</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">    .while</span> <span class="hljs-built_in">ebx</span> != <span class="hljs-number">0</span><br>        <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">edx</span><br>        <span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">edx</span><br>        <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-meta">    .endw</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br>gcd endp<br>end main<br><br></code></pre></td></tr></table></figure><h5 id="代码解释">代码解释</h5><p>在提供的代码中，欧几里得算法的实现部分位于<code>gcd proc</code>和<code>gcd endp</code>之间的代码块中。让我们逐行详细解释这部分代码的实现过程：</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">gcd proc<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span> <span class="hljs-comment">; 保存旧栈帧，建立新栈帧</span><br><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebx</span> <br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>]<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">12</span>]<br></code></pre></td></tr></table></figure><p>首先，过程开始时，保存旧的栈帧指针（ebp）并将当前栈帧指针（esp）赋给ebp，以建立新的栈帧。然后，将ebx和edx寄存器的值入栈保存。接下来，将第一个参数（dvar1）的值加载到eax寄存器，将第二个参数（dvar2）的值加载到ebx寄存器。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.if</span> <span class="hljs-built_in">eax</span> &lt; <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-meta">.endif</span><br></code></pre></td></tr></table></figure><p>通过使用xchg指令，将eax和ebx的值交换，以确保eax中存储的值始终大于等于ebx中存储的值。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs x86asm"><span class="hljs-meta">.while</span> <span class="hljs-built_in">ebx</span> != <span class="hljs-number">0</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">idiv</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">xchg</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><span class="hljs-meta">.endw</span><br></code></pre></td></tr></table></figure><p>接下来，使用循环来执行欧几里得算法的主要部分。使用while循环，条件是ebx不等于0。</p><ul><li><p>首先，通过使用xor指令将edx寄存器清零，以准备执行idiv（除法）操作。</p></li><li><p>然后，使用idiv指令将eax寄存器的值除以ebx寄存器的值。idiv指令执行有符号除法，并将商存储在eax中，余数存储在edx中。</p></li><li><p>将edx的值移动到eax寄存器，更新eax的值为余数。</p></li><li><p>最后，再次使用xchg指令交换eax和ebx的值。</p></li></ul><p>这个循环将一直执行，直到ebx等于0为止，此时最大公约数存储在eax寄存器中。</p><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">edx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebx</span><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">ret</span><br>gcd endp<br></code></pre></td></tr></table></figure><p>最后，恢复先前保存的ebx和edx的值，然后恢复旧的栈帧指针ebp。通过ret指令，从gcd过程返回到调用它的位置。</p><p>在主过程中，使用<code>call gcd</code>的方式调用gcd过程，将两个整数作为参数传递给它。然后，使用<code>push eax</code>将最大公约数的值压入堆栈，以便后续处理。</p><p>这样，在主过程中调用两次gcd过程，分别计算了dvar1和dvar2、dvar3和之前计算得到的最大公约数的最大公约数。最后，将最终的最大公约数（res）存储在变量中，并使用printf函数将其输出到控制台。</p><h4 id="冒泡排序">4. 冒泡排序</h4><p>编程写一个名为 <code>Bubble</code> 的冒泡排序子程序，主子程序间的参数传递通过堆栈完成；并写主程序验证它（array dword 10,1,8,7,5,3,4,6,2,9）。</p><h5 id="参考代码-16">参考代码</h5><figure class="highlight x86asm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs x86asm">INCLUDELIB kernel32<span class="hljs-number">.</span>lib<br>INCLUDELIB ucrt<span class="hljs-number">.</span>lib<br>INCLUDELIB legacy_stdio_definitions<span class="hljs-number">.</span>lib<br><span class="hljs-meta"></span><br><span class="hljs-meta">.386</span><br><span class="hljs-meta">.model</span> flat, stdcall<br><br>ExitProcess PROTO,<br><span class="hljs-symbol">    dwExitCode:</span> <span class="hljs-built_in">DWORD</span><br><br>printf PROTO C: <span class="hljs-built_in">DWORD</span>, :vararg<br>scanf PROTO C: <span class="hljs-built_in">DWORD</span>, :vararg<br><span class="hljs-meta"></span><br><span class="hljs-meta">.data</span><br>array <span class="hljs-built_in">dword</span> <span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">8</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">2</span>, <span class="hljs-number">9</span><br>msg <span class="hljs-built_in">byte</span> <span class="hljs-string">&#x27;%d &#x27;</span>, <span class="hljs-number">0</span><br><span class="hljs-meta"></span><br><span class="hljs-meta">.code</span><br><br>main Proc<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, lengthof array - <span class="hljs-number">1</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, offset array<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">call</span> BubbleSort<br><br>    <br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, lengthof array<br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esi</span>, <span class="hljs-number">0</span><br><span class="hljs-symbol">    print:</span><br>        <span class="hljs-keyword">pushad</span><br>        invoke printf, offset msg, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> array[<span class="hljs-built_in">esi</span> * <span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">popad</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>    <span class="hljs-keyword">loop</span> print<br><br>    invoke ExitProcess, <span class="hljs-number">0</span><br>main endp<br><br>BubbleSort proc<br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span> <span class="hljs-comment">;建立栈帧</span><br><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">edx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">8</span>] <span class="hljs-comment">;数组地址</span><br>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ecx</span>, <span class="hljs-built_in">dword</span> <span class="hljs-built_in">ptr</span> [<span class="hljs-built_in">ebp</span> + <span class="hljs-number">12</span>] <span class="hljs-comment">;数组末位元素索引</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">_out:</span> <span class="hljs-comment">;外层循环</span><br>    <span class="hljs-keyword">push</span> <span class="hljs-built_in">ecx</span><br>    <span class="hljs-keyword">xor</span> <span class="hljs-built_in">esi</span>, <span class="hljs-built_in">esi</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    _in:</span><br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, [<span class="hljs-built_in">edx</span> + <span class="hljs-built_in">esi</span> * <span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, [<span class="hljs-built_in">edx</span> + <span class="hljs-built_in">esi</span> * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>]<br>        <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">ebx</span><br><br>        <span class="hljs-keyword">jle</span> _continue<br>        <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edx</span> + <span class="hljs-built_in">esi</span> * <span class="hljs-number">4</span>], <span class="hljs-built_in">ebx</span><br>        <span class="hljs-keyword">mov</span> [<span class="hljs-built_in">edx</span> + <span class="hljs-built_in">esi</span> * <span class="hljs-number">4</span> + <span class="hljs-number">4</span>], <span class="hljs-built_in">eax</span><br><span class="hljs-symbol"></span><br><span class="hljs-symbol">    _continue:</span><br>        <span class="hljs-keyword">inc</span> <span class="hljs-built_in">esi</span><br>        <span class="hljs-keyword">loop</span> _<span class="hljs-keyword">in</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ecx</span> <span class="hljs-comment">;保护 ecx，使得外层循环必定执行 ecx 次</span><br><span class="hljs-keyword">loop</span> _<span class="hljs-keyword">out</span><br><br>    <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span> <span class="hljs-comment">;还原栈帧</span><br>    <span class="hljs-keyword">ret</span> <span class="hljs-number">8</span><br>BubbleSort endp<br>end main<br></code></pre></td></tr></table></figure><h1 id="微机总线">微机总线</h1><p>总线是微机系统中用于传输信息的公共通道，部件通过总线相互连接实现数据传输，部件之间需要遵守共同的总线规范。</p><h2 id="总线技术">总线技术</h2><h3 id="总线类型">总线类型</h3><h4 id="芯片总线">芯片总线</h4><ol type="1"><li>集成电路芯片内部，芯片级互联，或者系统中各种不同的器件连接起来的总线。</li><li>局部总线，微处理器的引脚信号。</li><li>片内总线，大规模集成电路内部连接。</li></ol><h4 id="内总线">内总线</h4><ol type="1"><li>模块级互联，主机内部功能单元互连的总线。</li><li>板级总线、母板总线，或系统总线</li><li>系统总线（System Bus）是微机系统的主要总线</li><li>内部总线从一条变为多条，形成多总线结构</li></ol><h4 id="外总线external-bus">外总线（External Bus）</h4><ol type="1"><li>设备级互连，微机与其外设或微机之间连接的总线</li><li>过去，指通信总线</li><li>现在，常延伸为外设总线</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305212223541.png" alt="微机总线层次结构" /><figcaption aria-hidden="true">微机总线层次结构</figcaption></figure><h3 id="总线的数据传输">总线的数据传输</h3><p>主设备（Master）：控制总线完成数据传输 从设备（Slave）：被动完成数据交换</p><p>同一时刻最多一个主设备控制总线，从设备无限制 同一时刻最多一设备通过总线发送数据，接受设备数量无限制</p><h3 id="总线的操作">总线的操作</h3><h4 id="请求和仲裁bus-request-arbitration">请求和仲裁（Bus request &amp; Arbitration）</h4><ol type="1"><li>使用总线的主模块提出申请</li><li>仲裁机制把总线分配给请求设备</li></ol><h4 id="寻址addressing">寻址（Addressing）</h4><p>主模块发出访问的从模块地址信息以及有关命令，启动从模块。</p><h4 id="数据传送-data-transfer">数据传送 （Data Transfer）</h4><p>源模块通过数据总线向目标模块发送信息。</p><h4 id="结束ending">结束（Ending）</h4><p>数据、地址、状态、命令信息均从总线上撤除，让出总线</p><h3 id="仲裁">仲裁</h3><p>总线仲裁：决定当前控制总线的主设备</p><h4 id="集中仲裁">集中仲裁</h4><ol type="1"><li>系统具有中央仲裁器（控制器）</li><li>负责主模块的总线请求和分配总线的使用</li><li>主模块有两条信号线：总线请求和总线响应</li></ol><h4 id="分布仲裁">分布仲裁</h4><ol type="1"><li>各个主模块都有自己的仲裁器和唯一的仲裁号</li><li>主模块请求总线时，发送其仲裁号</li><li>比较各个主设备仲裁号决定</li></ol><h3 id="同步方式">同步方式</h3><h4 id="同步时序">同步时序</h4><ol type="1"><li>总线操作过程由共用的总线时钟信号控制</li><li>适合速度相当的器件互连总线，否则需要准备好信号让快速器件等待慢速器件（半同步）</li><li>半同步时序需要增加READY等状态信号</li><li>处理器控制的总线时序采用同步时序</li></ol><h4 id="异步时序">异步时序</h4><ol type="1"><li>总线操作需要握手联络（应答）信号控制</li><li>传输的开始伴随有启动（选通或读写）信号</li><li>传输的结束有一个确认信号，进行应答</li><li>操作周期可变、可以混合慢速和快速器件</li></ol><h3 id="传输类型">传输类型</h3><h4 id="猝发传送数据块传送">猝发传送（数据块传送）</h4><p>给出起始地址，将固定块长的数据，一个就一个的从相邻地址读入或写出</p><h4 id="写后读read-after-write">写后读（Read-After-Write）</h4><p>先写后读，适用于校验。</p><h4 id="读修改写-read-modify-write">读修改写 （Read-Modify-Write）</h4><p>先读后写同一个地址单元，适用共享数据保护</p><h4 id="广播-broadcast">广播 （Broadcast）</h4><p>一个主设备对多个从设备的写入操作</p><h3 id="性能指标">性能指标</h3><h4 id="总线宽度8163264位">总线宽度(8,16,32,64位)</h4><p>总线能够同时传送的数据位数 位数越多，一次能够传送的数据量越大</p><h4 id="总线频率hz">总线频率Hz</h4><p>总线信号的时钟频率 时钟频率越高，工作速度越快</p><h4 id="总线带宽bandwidth">总线带宽（Bandwidth）</h4><p>单位时间传输的数据量MB/s 总线带宽越大，总线性能越高</p><p><span class="math inline">\(总线带宽=总线传输速率=吞吐率=传输的数据量\div所需时间\)</span></p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305212240227.png" alt="计算例子" /><figcaption aria-hidden="true">计算例子</figcaption></figure><h3 id="总线信号和时序">总线信号和时序</h3><h4 id="总线分类">总线分类</h4><h5 id="地址总线">地址总线</h5><ol type="1"><li>主从模块的地址总线输出</li><li>从模块的地址总线输入</li></ol><h5 id="数据总线">数据总线</h5><p>双向传输</p><h5 id="控制总线">控制总线</h5><ol type="1"><li>有输出也有输入信号</li><li>基本功能是控制存储器及I/O读写操作</li><li>还包括中断与DMA控制、总线仲裁、数据传输握手联络等</li></ol><h4 id="引脚信号">引脚信号</h4><p>引脚信号由以下方面构成</p><ol type="1"><li>信号的功能</li><li>信号的流向</li><li>有效方式</li><li>三态能力</li></ol><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305212249488.png" alt="引脚信号功能示意图" /><figcaption aria-hidden="true">引脚信号功能示意图</figcaption></figure><h4 id="总线时序">总线时序</h4><p>总线时序描述了总线信号的时间变化规律和相互关系。一个时钟周期是处理器的基本工作节拍。</p><h2 id="芯片">8086芯片</h2><h3 id="的引脚信号">8086的引脚信号</h3><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305212255626.png" /></p><h3 id="的总线时序">8086的总线时序</h3><p>8086的基本总线周期由四个时钟周期 <span class="math inline">\(T_{1-4}\)</span> 构成，存储器读和IO读，存储器写和IO写又可以分别统一到一个时序图表达。</p><h4 id="写总线周期">写总线周期</h4><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220018720.png" alt="写总线周期时序图1" /><figcaption aria-hidden="true">写总线周期时序图1</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220024070.png" alt="写总线周期图2" /><figcaption aria-hidden="true">写总线周期图2</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220025695.png" alt="Tw状态" /><figcaption aria-hidden="true">Tw状态</figcaption></figure><h4 id="读总线周期">读总线周期</h4><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220026533.png" alt="读总线周期图1" /><figcaption aria-hidden="true">读总线周期图1</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220019434.png" alt="读读总线周期时序图2" /><figcaption aria-hidden="true">读读总线周期时序图2</figcaption></figure><h3 id="中断请求和响应总线请求和响应复位时钟等信号的作用">中断请求和响应、总线请求和响应、复位、时钟等信号的作用</h3><p>在8086处理器的总线系统中，以下是各个信号的作用：</p><ol type="1"><li>中断请求和响应：<ul><li>中断请求（INTR）：外部设备通过将INTR引脚置为低电平来请求中断。设备可以向处理器发出中断请求，以便在需要时暂停当前正在执行的程序。</li><li>中断响应（INTA）：处理器在接收到中断请求后，通过将INTA引脚置为低电平来响应中断请求。这向外部设备发出确认信号，表明处理器已经准备好接收中断向量。</li></ul></li><li>总线请求和响应：<ul><li>总线请求（BUSRQ）：用于暂停处理器的总线操作，例如DMA控制器请求访问系统总线。</li><li>总线响应（BUSD）：用于确认处理器的总线请求，以便处理器知道其他设备已经释放了系统总线。</li></ul></li><li>复位信号（RESET）：<ul><li>复位信号用于将处理器重置为初始状态。当RESET引脚被拉低时，处理器会停止执行并重新初始化其内部状态。这是一个系统级信号，用于启动系统的初始化过程。</li></ul></li><li>时钟信号（CLK）：<ul><li>时钟信号提供处理器的基准时钟脉冲。它驱动处理器的内部时序和操作，并确保各个部件在正确的时间进行操作。处理器根据时钟信号的上升沿或下降沿执行指令和其他操作。</li></ul></li></ol><p>总的来说，中断请求和响应信号用于处理外部设备的中断，使处理器能够在需要时响应外部事件。总线请求和响应信号用于处理器和其他设备之间的总线控制和共享。复位信号用于将处理器重置为初始状态，而时钟信号则提供处理器操作的基准时序。这些信号在处理器的正常操作和系统的协调中起着重要的作用。</p><h3 id="总结">总结</h3><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220030792.png" alt="总结1" /> <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220030167.png" alt="总结2" /></p><h1 id="输入输出接口">输入输出接口</h1><h2 id="io接口典型模式">IO接口典型模式</h2><h3 id="内部结构">内部结构</h3><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220034451.png" alt="IO接口典型结构图" /><figcaption aria-hidden="true">IO接口典型结构图</figcaption></figure><h4 id="数据寄存器">数据寄存器</h4><p>保存处理器与外甥间交换的数据的寄存器。</p><h4 id="状态寄存器">状态寄存器</h4><p>保存外设或其接口电路当前的工作状态信息</p><h4 id="控制寄存器">控制寄存器</h4><p>保存控制接口电路和外设操作的有关信息。</p><h3 id="基本功能">基本功能</h3><ol type="1"><li>数据缓冲</li><li>信号变换</li></ol><h2 id="io端口的编址">IO端口的编址</h2><h3 id="端口与存储器地址独立编址">端口与存储器地址独立编址</h3><p>独立两个地址空间。</p><p>优点：不占用存储器空寂</p><p>缺点：指令功能简单，寻址方式不如存储器指令丰富</p><h3 id="统一编址">统一编址</h3><p>统一编排，共享地址空间，将IO地址映射到了存储器空间。</p><p>优点：不用专门设计IO指令和引脚，IO访问可复用存储器指令。</p><p>缺点：IO端口占据了存储器的地址空间。</p><h3 id="io地址译码">IO地址译码</h3><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220050176.png" alt="IO地址译码" /><figcaption aria-hidden="true">IO地址译码</figcaption></figure><h2 id="输入输出指令">输入输出指令</h2><p>输入指令 IN 和输出指令 OUT</p><h3 id="io寻址方式">IO寻址方式</h3><h4 id="直接寻址">直接寻址</h4><p>由IO指令直接提供8位IO地址，只能寻址最低256个地址。</p><p>在IO指令中，用i8表示这个地址，形式类似于立即数，但是在IO指令上就表示直接寻址的IO地址。</p><h3 id="dx间接寻址">DX间接寻址</h3><p>用16位寄存器DX保存IO地址。</p><p>IA-32处理器的IO地址共64k，每个地址对应一个8位端口，无需分段管理，最低256个地址可直接寻址或间接寻址访问，其余地址只能通过DX间接访问。</p><h3 id="数据传输量">数据传输量</h3><table><thead><tr class="header"><th>数据大小</th><th>寄存器</th></tr></thead><tbody><tr class="odd"><td>8位</td><td>AL</td></tr><tr class="even"><td>16位</td><td>AX</td></tr><tr class="odd"><td>32位</td><td>EAX</td></tr></tbody></table><h3 id="无条件传送和查询传送">无条件传送和查询传送</h3><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220100668.png" alt="数据传送方式" /><figcaption aria-hidden="true">数据传送方式</figcaption></figure><h4 id="软件控制的数据传送">软件控制的数据传送</h4><h5 id="无条件传送">无条件传送</h5><p>字面意思，根据原文意思可能是指无阻塞的传送。</p><p>例如数码管、按键、LED灯总是处于就绪状态的设备可采用无条件传送，数据缓冲通过三台缓冲器和锁存器实现。</p><h5 id="查询传送">查询传送</h5><p>询问外设工作状态并在外设准备好数据后开始数据传送。</p><h6 id="特点">特点</h6><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220111360.png" alt="流程图" /><figcaption aria-hidden="true">流程图</figcaption></figure><h6 id="编程">编程</h6><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220112996.png" alt="查询输入" /><figcaption aria-hidden="true">查询输入</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220112749.png" alt="查询输出" /><figcaption aria-hidden="true">查询输出</figcaption></figure><h5 id="中断传送">中断传送</h5><p>外设向处理器发送请求，处理器在满足条件的情况下中断暂停当前程序并与外设进行数据传送。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/image/202305220113833.png" alt="工作流程图" /><figcaption aria-hidden="true">工作流程图</figcaption></figure><h4 id="附加硬件控制的数据传送">附加硬件控制的数据传送</h4><h5 id="dma传送">DMA传送</h5><p>需要大量数据传送的外设，处理器转移控制权给DMA控制器，由其控制外设与存储器的数据传送。</p><h5 id="io处理器控制传送">IO处理器控制传送</h5><p>专门的IO处理器管理。</p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微机原理</tag>
      
      <tag>汇编语言</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>博客迁移之旅-从本地部署到使用GithubAction</title>
    <link href="/2022/12/13/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B9%8B%E6%97%85-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BD%BF%E7%94%A8GithubAction/"/>
    <url>/2022/12/13/%E9%85%8D%E7%BD%AE/%E5%8D%9A%E5%AE%A2%E8%BF%81%E7%A7%BB%E4%B9%8B%E6%97%85-%E4%BB%8E%E6%9C%AC%E5%9C%B0%E9%83%A8%E7%BD%B2%E5%88%B0%E4%BD%BF%E7%94%A8GithubAction/</url>
    
    <content type="html"><![CDATA[<h2 id="迁移原因">迁移原因</h2><p>原先我的博客是使用 hexo 在本地生成然后再发布到 Github Pages 上的。 但是很明显这种方式有很多弊端。</p><ol type="1"><li>写作和部署必须在我的本地机器上才能完成，基本断绝了远程写作的可能。</li><li>备份和恢复相当麻烦，对于我这种经常在主力机上重装系统的人来说非常的不友好。</li></ol><p>所以我就想着能不能将我的博客的生成和部署的过程使用免费的 CI/CD 工作流实现。 于是我就把目标放到了 Github Action 上。</p><h2 id="迁移过程">迁移过程</h2><p>非常幸运的是，因为 hexo 的用户数量非常的多，所以在 Github Action (以下简称 GH) 上有着丰富的预设脚本可以参考，同样的，相关的教程也非常的多。</p><p>这里我就参考了<a href="https://sanonz.github.io/2020/deploy-a-hexo-blog-from-github-actions/">这篇博客</a>的大部分流程，当然，由于我使用的主题和配置与他的并不完全一致，所以我的工作流配置文件也不完全相同。</p><p>以下为我的 Workflow 模版配置文件。</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">name:</span> <span class="hljs-string">HEXO_DEPLOY</span><br><span class="hljs-attr">on:</span><br>  <span class="hljs-attr">push:</span><br>    <span class="hljs-attr">branches:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">main</span><br><br><span class="hljs-attr">jobs:</span><br>  <span class="hljs-attr">build:</span><br>    <span class="hljs-attr">runs-on:</span> <span class="hljs-string">ubuntu-latest</span><br><br>    <span class="hljs-attr">steps:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Checkout</span> <span class="hljs-string">source</span><br>        <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/checkout@v1</span><br>        <span class="hljs-attr">with:</span><br>         <span class="hljs-attr">ref:</span> <span class="hljs-string">main</span><br>         <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">uses:</span> <span class="hljs-string">actions/setup-node@v3</span><br>        <span class="hljs-attr">with:</span><br>          <span class="hljs-attr">node-version:</span> <span class="hljs-string">lts/*</span><br>      <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Install</span> <span class="hljs-string">pandoc</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">         cd /tmp</span><br><span class="hljs-string">         wget -c https://github.com/jgm/pandoc/releases/download/2.14.0.3/pandoc-2.14.0.3-1-amd64.deb</span><br><span class="hljs-string">          sudo dpkg -i pandoc-2.14.0.3-1-amd64.deb</span><br><span class="hljs-string"></span>        <br>      <span class="hljs-bullet">-</span> <span class="hljs-attr">name:</span> <span class="hljs-string">Setup</span> <span class="hljs-string">hexo</span><br>        <span class="hljs-attr">env:</span><br>          <span class="hljs-attr">ACTION_DEPLOY_KEY:</span> <span class="hljs-string">$&#123;&#123;</span> <span class="hljs-string">secrets.HEXO_DEPLOY_SECRET</span> <span class="hljs-string">&#125;&#125;</span><br>        <span class="hljs-attr">run:</span> <span class="hljs-string">|</span><br><span class="hljs-string">          mkdir -p ~/.ssh/</span><br><span class="hljs-string">          echo &quot;$ACTION_DEPLOY_KEY&quot; &gt; ~/.ssh/id_rsa</span><br><span class="hljs-string">          chmod 600 ~/.ssh/id_rsa</span><br><span class="hljs-string">          ssh-keyscan github.com &gt;&gt; ~/.ssh/known_hosts</span><br><span class="hljs-string">          git config --global user.email &quot;80513590+OOJ2003@users.noreply.github.com&quot;</span><br><span class="hljs-string">          git config --global user.name &quot;OOJ2003&quot;</span><br><span class="hljs-string">          npm install -g hexo-cli </span><br><span class="hljs-string">          npm install</span><br><span class="hljs-string">          hexo clean</span><br><span class="hljs-string">          hexo d</span><br><span class="hljs-string"></span>          <br>      <br></code></pre></td></tr></table></figure><p>由于我使用的 latex 插件需要 pandoc 环境，所以我额外加入了安装 pandoc 的步骤。</p><h2 id="使用方式">使用方式</h2><p>与迁移前其实差异不大，但是不需要手动执行命令去部署了，只要写完后 commit 就会自动触发生成和部署。</p><h2 id="碎碎念">碎碎念</h2><p>我使用的主题支持自动生成博客文章的创建时间戳和更新时间戳，但是转到使用 Github Action 部署后每篇文章的更新时间就变成了最新的 commit 的时间戳。。。看了主题的 issue 区貌似有别人也遇到了类似的问题，而且没有什么特别好的解决方法。</p><p>不过非常幸运的是，如果在博文源文件的 Front-matter 里手动加入一个 updated 字段，就会覆盖掉自动生成的时间戳，所以就将就着这么写了（？</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>k40s与类原生的奇妙碰撞</title>
    <link href="/2022/09/25/%E9%85%8D%E7%BD%AE/k40s%E4%B8%8E%E7%B1%BB%E5%8E%9F%E7%94%9F%E7%9A%84%E5%A5%87%E5%A6%99%E7%A2%B0%E6%92%9E/"/>
    <url>/2022/09/25/%E9%85%8D%E7%BD%AE/k40s%E4%B8%8E%E7%B1%BB%E5%8E%9F%E7%94%9F%E7%9A%84%E5%A5%87%E5%A6%99%E7%A2%B0%E6%92%9E/</url>
    
    <content type="html"><![CDATA[<h2 id="瞎扯时间">瞎扯时间</h2><p>老手机用了快三年了，虽然我感觉性能还跟的上时代，但是电池的损耗尤为严重，而且屏幕还脱胶了，于是我决定买台新机爽爽，挑来选去，最终又买了红米。。。</p><p>倒不是我不喜欢其他品牌，但是开放 bootloader 锁并且内核开源的手机品牌太少了，考虑到价格和性能，基本上只有小米和一加符合条件。但是，你懂的，一加从 8pro 开始一路走下坡路，甚至连 氢/氧 OS 都换成了老东家的 ColorOS。所以我就买了 k40s 来当我的主力机。</p><p>新机到手没法直接解锁 bl 锁，需要登陆账户7天才行，有点蛋疼。。解锁完毕后我就刷入了一个名为 PixelExperience 的类原生，官方还没有适配，所以我刷了个第三方维护的包，等之后有 offical 支持后我就再刷一次。</p><p>这个类原生的特点就是仿 PixelUI ，也就是谷歌亲儿子的 rom 。体验很难一言蔽之，关于相关的介绍也很多，我就不过多阐述了，这里更多的还是记录下我的玩机配置。</p><h2 id="面具模块">面具模块</h2><p>现在基本上都是用 magisk 来管理 root 权限了，而且 magisk 还支持刷入各种 modules ，玩法非常的多变。</p><h3 id="自动救砖模块">自动救砖模块</h3><p>懂得都懂，来源可以在酷安找到。</p><h3 id="zygisk-lsposed">zygisk-LSPosed</h3><p>用于 LSP 框架的使用，在 GitHub 上可以找到 release 。</p><h3 id="存储空间隔离面具模块">存储空间隔离面具模块</h3><p>启动存储空间隔离的增强模式，来源在存储空间隔离的配置界面可以找到。</p><h3 id="shamiko">Shamiko</h3><p>用于隐藏模块和面具，在 GitHub 上可以找到（非开源）。</p><h3 id="pixel-launcher-mods-overlay">Pixel Launcher Mods Overlay</h3><p>Pixel Launcher Mods 的配套模块，用于开启更多设置选项。</p><h2 id="lsp-模块">LSP 模块</h2><p>LSPosed 是一个改进过的 xp 框架，性能和使用感受要强过 edxp 和太极不少，基本上成了新机想要体验 xp 模块的首选了，另外 lsp manager 自带一个模块市场，体验上还是很不错的。</p><h3 id="thanx">Thanx</h3><p>灭霸，冻结应用、管理权限等等等等的神器，用过的都说好，合理配置后可以极大幅度提升续航表现和系统流畅度。</p><h3 id="哔哩漫游">哔哩漫游</h3><p>主要功能是看海外番剧，但实际上各种其他小功能反而更让人感到惊喜。</p><h3 id="知了">知了</h3><p>知乎去广告，以及其他各种优化功能。</p><h3 id="qx模块">QX模块</h3><p>消息防撤回以及自动抢红包。</p><h3 id="qd">QD</h3><p>起点阅读自动签到和去广告。</p><h3 id="自动记账">自动记账</h3><p>配合钱迹使用。</p><h2 id="其他搞机应用">其他搞机应用</h2><h3 id="momo">momo</h3><p>用来自己检测环境是否异常，通过 shamiku 等手段让 momo 检测不到基本上就能过银行的检测了。</p><h3 id="shizuku">Shizuku</h3><p>rikka 的一系列应用之一，提供稳定的 api 给其他应用使用。</p><h3 id="swift-backup">Swift Backup</h3><p>备份应用。</p><h3 id="李跳跳">李跳跳</h3><p>自动跳过广告。</p><h3 id="存储空间隔离">存储空间隔离</h3><p>将不遵循设计规范应用的读写重定向到指定的文件夹中，根目录下再也没有奇怪的文件夹了😍</p><h3 id="shelter">Shelter</h3><p>开启工作空间，隔离应用或者用于双开。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置记录</tag>
      
      <tag>体验</tag>
      
      <tag>安卓</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>软路由/路由器配置代理后出现的git错误</title>
    <link href="/2022/09/25/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E8%B7%AF%E7%94%B1-%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84git%E9%94%99%E8%AF%AF/"/>
    <url>/2022/09/25/%E9%85%8D%E7%BD%AE/%E8%BD%AF%E8%B7%AF%E7%94%B1-%E8%B7%AF%E7%94%B1%E5%99%A8%E9%85%8D%E7%BD%AE%E4%BB%A3%E7%90%86%E5%90%8E%E5%87%BA%E7%8E%B0%E7%9A%84git%E9%94%99%E8%AF%AF/</url>
    
    <content type="html"><![CDATA[<p>把大一用的老路由刷了openwrt后配置了魔法(ShadowSocksR Plus+)，然后git就commit不动了。。。Orz</p><p>排查后发现是路由器上代理的锅。。。但是奇怪的是使用clash for windows 这种客户端反而可以，参考这份 <a href="https://github.com/vernesong/OpenClash/issues/1960">issue</a>，配置了ssh over https就解决了√</p><p>这种情况不止出现在 ShadowSocksR Plus+上，open clash貌似也是，虽然不知道究竟为什么会这样，反正能用就行。</p><p><a href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">Github上配置ssh over https port的文档</a></p>]]></content>
    
    
    <categories>
      
      <category>问题复现与解决</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
      <tag>代理</tag>
      
      <tag>软路由</tag>
      
      <tag>opentwrt</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea配置jsp开发环境</title>
    <link href="/2022/09/02/%E9%85%8D%E7%BD%AE/idea%E9%85%8D%E7%BD%AEjsp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/09/02/%E9%85%8D%E7%BD%AE/idea%E9%85%8D%E7%BD%AEjsp%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<h2 id="准备工作">准备工作</h2><p>教育邮箱，学生证，代理工具（可选），<a href="https://steampp.net/">watt toolkit</a> （可选，用于在没有代理工具的情况下访问 github），<a href="https://tomcat.apache.org/download-migration.cgi">tomcat 二进制分发</a>（此处使用的为 tomcat10.2.3)。</p><h2 id="具体配置">具体配置</h2><h3 id="教育认证">教育认证</h3><p>如果你已完成了 jetbrains 的教育认证，跳过这一部分。</p><ol type="1"><li>（可选）进行 github 学生包认证，需要教育邮箱和学生证照片，不要使用代理，学生认证会根据 ip 判断位置。（注：除本项外其余均建议在代理环境下完成，外网的连接通畅对查找资料和下载安装资源有很大的帮助。）</li><li>使用学生包认证 jetbrains 教育认证，如果没有做 1，可以直接使用教育邮箱认证。</li><li>下载 <a href="https://www.jetbrains.com/zh-cn/toolbox-app/">toolbox</a> 并登录你注册的 jetbrains 账户，安装 IntelliJ IDEA Ultimate 版本，当你认证了学生身份后，你能够免费的使用这些付费 ide 。</li></ol><h3 id="新建项目">新建项目</h3><p>打开 idea，然后按照下图新建项目，位置选择一个你喜欢的且不包含特殊字符的就行。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/763c604d3c3745dfdc2b8d393e954102-20220902091924-03802b.png" alt="配置图" /></p><p>生成器使用 jakarta ee，模板 web 应用程序，构建系统 maven 。</p><p>应用程序服务器首次创建项目需要手动导入，选择新建 tomcat 服务器，然后地址选择 tomcat 解压后所在的地址。</p><p>jdk 则不用预先安装，在项目配置里选择下载 jdk 后找到 1.8 版本的 jdk 就可以了，idea 会自动处理好，推荐 openjdk 或者 azul 。</p><h3 id="项目配置">项目配置</h3><p>下图是项目的文件结构，接下来我们写的 jsp 文件均保存在 webapp 目录或其子目录内。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/f36cb6aaf7bd7760b06d12fec95b4e09-20220902093318-2abf13.png" /></p><p>用 idea 打开项目，你的界面应该和下图类似。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/c2b54d6cda5583ed7b74844e83b03afd-20220902093630-a42199.png" /></p><p>右上角的绿色三角和红色虫子分别是运行和调试，点击绿色三角，idea 会自动构建并通过浏览器打开，如下图所示。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/a1fe7e8f229b44ffe8d6917a5c5f5b73-20220902093851-7f15f3.png" /></p><p>在 webapp 目录中新建 ex1 目录，然后在 ex1 中新建 inputWord.jsp 和 showDictionary.jsp 文件，文件内容如下。</p><p>inputWord.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Title<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: small&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;showDictionary.jsp&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;get&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">form</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span><br>            请输入单词（用空格分隔）：<br>            <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;word&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;送出&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>showDictionary.jsp</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs html">&lt;%@ page contentType=&quot;text/html;charset=UTF-8&quot; language=&quot;java&quot; %&gt;<br>&lt;%@ page import=&quot;java.util.*&quot; %&gt;<br><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">body</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;background-color: white&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;font-size: medium&quot;</span>&gt;</span><br>    &lt;%!<br>        TreeSet<span class="hljs-tag">&lt;<span class="hljs-name">String</span>&gt;</span> dictionary = new TreeSet<span class="hljs-tag">&lt;&gt;</span>();<br>        public void addWord(String s) &#123;<br>            dictionary.addAll(Arrays.asList(s.split(&quot; &quot;)));<br>        &#125;<br>    %&gt;<br><br>    &lt;%<br>    String str = request.getParameter(&quot;word&quot;);<br>        addWord(str);<br>        for (String si: dictionary) &#123;<br>            out.print(&quot;&quot; + si + &quot;<span class="hljs-tag">&lt;<span class="hljs-name">br</span>/&gt;</span>&quot;);<br>        &#125;<br>    %&gt;<br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>运行后应该如下图所示。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/9b70520b277f2ef5e293d1bc8b48bb90-20220902094827-a9db0c.png" /></p><p>也可以在 idea 中打开，按下图第一个按钮即可。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/b094b52298f7f6a7e90c744bd3408322-20220902094923-901348.png" /></p><p>继续测试，打开页面输入内容后点击送出。 <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/f71cdfda9dc0baa07e058967dd6a2510-20220902102314-599d34.png" /> <img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/982b07a886ab0989c602d901acb1eab1-20220902102337-708269.png" /></p><p>到此，大致配置已经完成。</p><h2 id="疑难解惑">疑难解惑</h2><h3 id="idea-无法自动补全部分函数报错且提示找不到方法调用-out.print">idea 无法自动补全部分函数，报错且提示找不到方法调用 out.print()</h3><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/c289127e57b7e0be5ffe840508a84971-20220902095201-8d62dd.png" /></p><p>打开 文件/项目结构/模块 然后点击加号选择 jar 或目录，然后选择你安装的 tomcat 中的 lib 目录，应用配置并重启 idea。</p><h3 id="tomcat-日志乱码">tomcat 日志乱码</h3><p>idea 设置里打开文件编码选项，里面所有选择全部修改为 utf-8，bom 选项为不带 bom。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/09/02/43831753259c55cd713d08a1aebb645a-20220902101726-4f97e6.png" /></p><h3 id="使用-out.print-后-jsp-页面乱码">使用 out.print 后 jsp 页面乱码</h3><p>创建如下函数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> String <span class="hljs-title function_">toUTF8</span><span class="hljs-params">(String s)</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(s.getBytes(), StandardCharsets.UTF_8);<br>&#125;<br></code></pre></td></tr></table></figure><p>非常典型的 utf-8 编码问题，使用 out.print 或类似函数时调用上述静态方法包装你的字符串。</p><h3 id="中文界面字体...etc">中文/界面/字体...etc</h3><p>设置选项中点击插件，搜索 chinese，安装中文语言包。</p><p>主题我使用的是 material theme 插件的 one dark pro，字体为 fira code nerd font 。</p><p>其余推荐插件：</p><ol type="1"><li>rainbow brackets (彩虹括号)</li><li>Atom Material Icons (material design 风格的图标包)</li><li>copilot (github 的 ai 代码补全工具，需要 github 学生包才能免费使用)</li></ol>]]></content>
    
    
    <categories>
      
      <category>环境配置</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置记录</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>一点二进制</title>
    <link href="/2022/07/30/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B0%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E9%81%93%E9%A2%98/"/>
    <url>/2022/07/30/%E9%A2%98%E8%A7%A3/%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%B0%E4%BA%BA%E7%9A%84%E7%AC%AC%E4%B8%80%E9%81%93%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<p>虽然转到二进制已经有段时间了。。但是却没写过什么题目，所以在 buu 找到了些简单的题目来写。</p><h1 id="easyre">easyre</h1><p>首先是第一题，<a href="https://buuoj.cn/challenges#easyre">easyre</a>。</p><p>题目给了个可执行文件，先放到 exeinfo 里面看看情况。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022-07-30_23-112022-07-3019.png" alt="exeinfo的检测" /><figcaption aria-hidden="true">exeinfo的检测</figcaption></figure><p>所以是个没加壳层的64位程序，用 ida64 打开并找到 main 函数。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022-07-30_23-142022-07-3034.png" /></p><p>按下 f5 生成伪代码，flag 如图所示。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022-07-30_23-172022-07-3054.png" alt="flag" /><figcaption aria-hidden="true">flag</figcaption></figure><h1 id="reverse1">reverse1</h1><p>丢到 exeinfo 分析。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022-07-30_23-292022-07-3039.png" alt="exeinfo" /><figcaption aria-hidden="true">exeinfo</figcaption></figure><p>直接运行试试。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-000327.png" alt="直接运行" /><figcaption aria-hidden="true">直接运行</figcaption></figure><p>拖到 ida 里面看看。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-001022.png" alt="string views" /><figcaption aria-hidden="true">string views</figcaption></figure><p>按下 shift + f12 ，切换到字符串的界面，联想到运行时的 "input the flag" 和 "wrong flag" ， 可以通过查找交叉引用找到调用的函数。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-001259.png" alt="xref" /><figcaption aria-hidden="true">xref</figcaption></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-001641.png" alt="伪代码" /><figcaption aria-hidden="true">伪代码</figcaption></figure><p>不难发现这个地方的 sub_14001128F() 函数应该是类似于 scanf() 一类的函数，将用户输入存入 Str1 中并与 Str2 比较。</p><p>所以只要找到 Str2 的值就能找到 flag 。</p><p>显然代码上半部分对 Str2 进行了处理，首先我们找到 Str2 的原始值。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-002108.png" alt="Str2" /><figcaption aria-hidden="true">Str2</figcaption></figure><p>显然 Str2 = "{hello_world}"，再来看看上面的代码，是将 Str2 中的 ascii 码为 111 的字符替换为 48 。</p><p>在这两个数字上按下 r ，结果如图。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-002924.png" /></p><p>所以 flag 即为 "{hell0_worl0}" 。</p><h1 id="reverse2">reverse2</h1><p>不是 win 上的可执行程序。。所以直接拖到 ida64 上看看。</p><p>如法炮制，同样是通过找寻找使用类似 “flag” 字样的字符串找到主函数。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-004643.png" alt="主函数伪代码" /><figcaption aria-hidden="true">主函数伪代码</figcaption></figure><p>这里已经将数字转换成了 ascii 字符，所以只要找到 flag 的原始值即可。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-005321.png" alt="flag变量" /><figcaption aria-hidden="true">flag变量</figcaption></figure><p>所以加密后的 flag 为 "{hack1ng_fo1_fun}" 。</p><h1 id="reverse3">reverse3</h1><p>用 exeinfo 查看信息。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-005641.png" alt="exeinfo" /><figcaption aria-hidden="true">exeinfo</figcaption></figure><p>无壳32位程序，先尝试运行。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-011122.png" alt="尝试运行" /><figcaption aria-hidden="true">尝试运行</figcaption></figure><p>拖到 ida 里面，先去找找有无包含 "flag" 字样的字符串。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-011416.png" alt="奇怪的字符串" /><figcaption aria-hidden="true">奇怪的字符串</figcaption></figure><p>的确找到了，但是也出现了一条奇怪的字符串，非常像是 base64 编码使用的字母。</p><p>通过 "wrong flag!" 找到主函数。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-012144.png" alt="主函数" /><figcaption aria-hidden="true">主函数</figcaption></figure><p>函数伪代码比较长，为了分析方便，再贴一段代码块。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> __cdecl <span class="hljs-title function_">main_0</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **argv, <span class="hljs-type">const</span> <span class="hljs-type">char</span> **envp)</span><br>&#123;<br>  <span class="hljs-type">size_t</span> v3; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">const</span> <span class="hljs-type">char</span> *v4; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">size_t</span> v5; <span class="hljs-comment">// eax</span><br>  <span class="hljs-type">char</span> v7; <span class="hljs-comment">// [esp+0h] [ebp-188h]</span><br>  <span class="hljs-type">char</span> v8; <span class="hljs-comment">// [esp+0h] [ebp-188h]</span><br>  <span class="hljs-type">signed</span> <span class="hljs-type">int</span> j; <span class="hljs-comment">// [esp+DCh] [ebp-ACh]</span><br>  <span class="hljs-type">int</span> i; <span class="hljs-comment">// [esp+E8h] [ebp-A0h]</span><br>  <span class="hljs-type">signed</span> <span class="hljs-type">int</span> v11; <span class="hljs-comment">// [esp+E8h] [ebp-A0h]</span><br>  <span class="hljs-type">char</span> Destination[<span class="hljs-number">108</span>]; <span class="hljs-comment">// [esp+F4h] [ebp-94h] BYREF</span><br>  <span class="hljs-type">char</span> Str[<span class="hljs-number">28</span>]; <span class="hljs-comment">// [esp+160h] [ebp-28h] BYREF</span><br>  <span class="hljs-type">char</span> v14[<span class="hljs-number">8</span>]; <span class="hljs-comment">// [esp+17Ch] [ebp-Ch] BYREF</span><br><br>  <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; ++i )<br>  &#123;<br>    <span class="hljs-keyword">if</span> ( (<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>)i &gt;= <span class="hljs-number">100</span> )<br>      j____report_rangecheckfailure();<br>    Destination[i] = <span class="hljs-number">0</span>;<br>  &#125;<br>  sub_41132F(<span class="hljs-string">&quot;please enter the flag:&quot;</span>, v7);<br>  sub_411375(<span class="hljs-string">&quot;%20s&quot;</span>, (<span class="hljs-type">char</span>)Str);<br>  v3 = j_strlen(Str);<br>  v4 = (<span class="hljs-type">const</span> <span class="hljs-type">char</span> *)sub_4110BE(Str, v3, v14);<br>  <span class="hljs-built_in">strncpy</span>(Destination, v4, <span class="hljs-number">40u</span>);<br>  v11 = j_strlen(Destination);<br>  <span class="hljs-keyword">for</span> ( j = <span class="hljs-number">0</span>; j &lt; v11; ++j )<br>    Destination[j] += j;<br>  v5 = j_strlen(Destination);<br>  <span class="hljs-keyword">if</span> ( !<span class="hljs-built_in">strncmp</span>(Destination, Str2, v5) )<br>    sub_41132F(<span class="hljs-string">&quot;rigth flag!\n&quot;</span>, v8);<br>  <span class="hljs-keyword">else</span><br>    sub_41132F(<span class="hljs-string">&quot;wrong flag!\n&quot;</span>, v8);<br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>22行应该是读取输入到 Str ，24行将 v4 拷贝到 Destination 上，然后27~28将 Destination 上每一位都加上所在下标。</p><p>所以搞清楚 v4 是什么就可以求出 Destination 了，所以接下来来看看24行的那个奇怪函数究竟做了什么。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-015312.png" alt="奇怪函数的内部" /><figcaption aria-hidden="true">奇怪函数的内部</figcaption></figure><p>emmm, 完全看不懂，但是里面有个奇怪的变量，点进去看看。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-015907.png" alt="奇怪的变量" /><figcaption aria-hidden="true">奇怪的变量</figcaption></figure><p>猜测这个函数应该用于 base64 编码，那么 main 函数里面干的事情就如下。</p><ol type="1"><li>Destination: [char;100] 置0。</li><li>读入输入至变量 Str 中。</li><li>将 Str base64 加密后存入 v4。</li><li>将 v4 拷贝到 Destination 上。</li><li>将 Destination 上每一位都加上自己的下标。</li><li>比较 Destination 和 Str2 。</li></ol><p>继续查找 Str2 。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-021553.png" alt="Str2" /><figcaption aria-hidden="true">Str2</figcaption></figure><p>综上，可以编写以下脚本。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> base64<br><br>s = <span class="hljs-string">&quot;e3nifIH9b_C@n@dH&quot;</span><br>temp = <span class="hljs-string">&quot;&quot;</span><br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-built_in">len</span>(s)):<br>    temp += <span class="hljs-built_in">chr</span>(<span class="hljs-built_in">ord</span>(s[i]) - i)<br><br><span class="hljs-built_in">print</span>(base64.b64decode(temp))<br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/07/31/20220731-023438.png" alt="运行结果" /><figcaption aria-hidden="true">运行结果</figcaption></figure>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>reverse</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>苦难之路-Arch使用漫谈</title>
    <link href="/2022/07/20/%E9%85%8D%E7%BD%AE/%E8%8B%A6%E9%9A%BE%E4%B9%8B%E8%B7%AF-arch%E4%BD%BF%E7%94%A8%E6%BC%AB%E8%B0%88/"/>
    <url>/2022/07/20/%E9%85%8D%E7%BD%AE/%E8%8B%A6%E9%9A%BE%E4%B9%8B%E8%B7%AF-arch%E4%BD%BF%E7%94%A8%E6%BC%AB%E8%B0%88/</url>
    
    <content type="html"><![CDATA[<p>突然发现从第一次在实体机上装上 Arch 到现在已经有大半年的时间了，现在基本上算是熟悉了在 Linux 上的工作流程，写点东西缅怀下从前，<del>顺便记录下相关的配置</del>。</p><p>由于各种原因，已经重新回到 win 上了，本文停更。</p><h1 id="前言">前言</h1><h2 id="稀碎的理由">稀碎的理由</h2><p>对外行人解释可能说下方便开发就可以糊弄过去了，但是现在的生态和以前截然不同，稍微有点了解的人都知道现在在windows上搞开发已经远好过从前了。</p><p>比方说开发 Linux 原生的项目，原先是要么实体机 Ubuntu，要么虚拟机里放个 Ubuntu，但是有了 wsl 就截然不同了。最开始的 wsl1 还是类似于 wine 一样的兼容层，后来的 wsl2 直接就变成了基于 hyper-v 的虚拟机。虽然其还有跨系统文件读写速率等诸多小毛病，但是耐不住它安装管理方便还免费轻巧，配合 vscode remote 和新的 terminal 应付常规开发完全没有问题。</p><p>虽然一直骂微软是个只看钱的商业公司，但是这几年微软确实为开源社区做了不少贡献。比如说收购 GitHub 后给个人开放了无限的私有库数量还有免费的 GitHub Action，再比如说 vscodium，lsp，dsp 等等等等。总之在M$的大力投入下，虽然生态还比不上 Mac 那么精致，但是 Windows 上的开发体验已经是远超从前了。</p><p>所以用 Linux 的理由究竟是什么呢？另一个 Linux 对我来说的卖点是安全和隐私，绝大多数软件包都是开源的，不太可能藏有恶意代码，而且权限管理做的比windows好，不至于装个 qq 就同时安装了高权限的的内核驱动。所以 Linux 比 Windows 更安全。。吗？</p><p>先不提微软官方的沙盒环境，开源社区里也有免费的 sandboxie 可用，再不济，可以开个虚拟机啊，我现在笔记本的内存加到了 32gb，完全可以装个精简的 win 然后在里面放这些不干净的软件。而且更要命的是，Linux 上的这些软件包真的更隐私吗？aur 上面一堆闭源代码的包，你说这些包有没有在里面放些遥测功能我是不信的。</p><p>可能是矫情吧，毕竟出生在这个隐私不值钱的大政府国家，我不相信国内这些公司的底线，却意外的相信这些“境外势力”的产品。也许是更严苛的法规如欧盟🇪🇺那些隐私条例或者是数不清的对这些的企业的巨额罚款给了我信心？</p><p>所以思来想去，可能只有“折腾”这个词才能体现出来我切换到 Arch 的理由了，折腾给我带来了乐趣，让我获得了某种满足感。可能和刷机差不多吧，你问我为什么解锁手机的 bootloader，理由也是向上面这样稀碎的站不住脚，真正的理由可能只有“好玩”。</p><h2 id="why-arch">why Arch?</h2><p>Linux 发行版那么多，每种发行版也都有属于自己的特点，比如最常见的 Debian 系，就提供了相对完善的驱动支持，而且基本上支持 Linux 的软件优先提供的打包方式也是 deb，所以生态相当不错。</p><p>我用 Arch 的最主要原因也是 Arch 出色的软件生态，虽然很多包并没有官方提供打包成 Arch 系的格式（.pkg.tar.xz），但是得益于活跃的社区支持，绝大多数包都能在 aur 上找到相关的 pkgbuild 文件，配合 yay 等 aur 助手，体验还是相当不错的。</p><p>另一点就是 Arch 是滚动更新的，相较于其他传统发行版的 stable 或者 LTS 版本能够更快的接收到更新 -- 只要更新一些软件包即可。</p><h2 id="which-arch">which Arch?</h2><p>一般来说诸多主流发行版都有其衍生的发行版，Arch 也不例外，比如 Manjaro 就是 Arch 系的。</p><p>我是经历了 Arch ”原版“（<a href="https://archlinuxgui.in">Arch Install GUI</a>），<a href="https://manjaro.org">Manjaro KDE</a>，以及最近几个月终于稳定下来不再折腾的 <a href="https://endeavouros.com">EndeavourOS</a>。</p><p>这三个其实都蛮不错的，但是使用和配置上还是有些许不同，Manjaro 是其中最特别的那个。</p><p>其余两者，前者则是纯粹的原版 Arch ，只是搭配了桌面环境和一个图形化安装程序（Calamares)。后者与前者类似，但是额外提供了几个安装成功后的辅助配置软件，比如安装一些办公套件或者指导开启蓝牙等等。</p><p>为什么说 Manjaro 特别呢？Manjaro 严格来说并没有直接使用 Arch 仓库里的软件包，相反，他有自己的软件源，甚至国内的镜像也不同，这些仓库里的软件包本质上还是 Arch 仓库里面那些，但是一般来说经过了一周或者数周的测试，相对稳定性会更好。但是如果你使用 aur 上的软件包，就有一定概率会出现依赖不满足的情况甚至是滚挂，有时还是很令人恼火的。</p><p>对于大多数想要玩一玩 Linux 的人来说，Manjaro 仍然是不二之选，几乎所有配置，包括内核和驱动等等都可以通过 Manjaro 官方提供的工具配置，十分的方便。</p><p>我现在使用的这个发行版，EndeavourOS，则更类似于原版 Arch 的体验，可以畅快的使用原版的所有功能，并且有一个还算活跃的社区提供很多帮助。</p>]]></content>
    
    
    <categories>
      
      <category>随笔</category>
      
    </categories>
    
    
    <tags>
      
      <tag>配置记录</tag>
      
      <tag>linux</tag>
      
      <tag>arch</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>react学习记录</title>
    <link href="/2022/07/17/%E6%8A%80%E6%9C%AF/react%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <url>/2022/07/17/%E6%8A%80%E6%9C%AF/react%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</url>
    
    <content type="html"><![CDATA[<p>很早之前有学过一点简单的前端，主要就是原生的 js 和 html 那些玩意儿，但是我这条懒狗也没坚持下去。。。趁着暑假，我得高低整点能看的玩意儿出来，不然学了小一年的计算机连个界面都搓不出来也太挫了。</p><p>原先定的计划是搞点 vue，但是捏，模板语法看着确实有点奇怪，而且 react 函数式的写法看起来有点意思，所以就决定是你了，react！</p><h1 id="the-basis">The Basis</h1><h2 id="环境准备">环境准备</h2><blockquote><p>工欲善其事，必先利其器</p></blockquote><pre><code class="hljs">              --《论语·卫灵公》</code></pre><p>毕竟现在已经是 2202 年了，项目开发一般都会有专门的脚手架来配置，这里我就采用了 pnpm + vite 的配置。</p><p>pnpm 是个新的包管理器，但是它有很多的创新之处，所以节省空间还比较快。vite 也是一样的道理，这个新的打包工具构建速度非常的快，比 webpack 快到不知道哪里去了 🤓。</p><p>编辑器我选择的是 vscode，以下为需要安装的插件</p><ol type="1"><li><a href="https://marketplace.visualstudio.com/items?itemName=dsznajder.es7-react-js-snippets">ES7+ React/Redux/React-Native/JS snippets</a> 这个插件提供了 react 相关的补全</li><li><a href="https://marketplace.visualstudio.com/items?itemName=antfu.vite">vite</a> 用来搭配 vite 项目使用</li><li><a href="https://marketplace.visualstudio.com/items?itemName=dbaeumer.vscode-eslint">eslint</a> 提供针对 js/ts 的静态检查</li><li><a href="https://marketplace.visualstudio.com/items?itemName=esbenp.prettier-vscode">prettier</a> 代码格式化工具</li></ol><p>首先来创建项目</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">pnpm create vite<br></code></pre></td></tr></table></figure><p>项目的配置很简单，遵循指示选择后回车即可。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/image-20220717190437518.png" alt="项目配置" /><figcaption aria-hidden="true">项目配置</figcaption></figure><p>大致效果如下</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/image-20220717224154452.png" alt="浏览器演示画面" /><figcaption aria-hidden="true">浏览器演示画面</figcaption></figure><p>顺带一提，vite 插件也提供了在 vscode 中的实时预览</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022-07-17_22-452022-07-17.png" alt="vscode中的预览" /><figcaption aria-hidden="true">vscode中的预览</figcaption></figure><h2 id="基础的函数组件和-jsx">基础的函数组件和 jsx</h2><p>jsx 是 react 最有趣的特性之一，通过 jsx ,可以很轻松的将视图和逻辑绑定到一起。换言之，就是不用再去单独处理 html 和 css 了，基本上所有的东西都可以扔到 jsx 里面来写。</p><h3 id="根节点和实际的-dom-树">根节点和实际的 dom 树</h3><p>当我们通过 react 去创建组件时，实例化的组件必定会在 dom 树上有所体现。比如一个 button 组件可能就是一个套着 div 并且绑定了相关回调函数的 button （原生）组件。所以为了将我们写的组件渲染到浏览器中，react 必须将我们的组件通过某种方式挂载到入口的 html 文件中。</p><p>在这个项目里，react 则是创建了一个根组件，并将我们创建的其他组件在根组件中组合，最后将根组件挂载到 html 文件上。</p><p>这点从项目中 index.html 和 main.jsx 的文件内容也可以看出。</p><p>index.html</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">html</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">html</span> <span class="hljs-attr">lang</span>=<span class="hljs-string">&quot;en&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">charset</span>=<span class="hljs-string">&quot;UTF-8&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;icon&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;image/svg+xml&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;/vite.svg&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attr">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1.0&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>Vite + React<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;root&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;module&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/src/main.jsx&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>main.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./index.css&quot;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>)).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure><p>显然，这里 react 是通过 getElementByID 这个方法获取了 index.html 中 id 为 root 的 dom 元素，并在其中渲染了 &lt;App /&gt; 这个组件。</p><p>App.jsx</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> reactLogo <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./assets/react.svg&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;./App.css&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://vitejs.dev&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;/vite.svg&quot;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;logo&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;Vite logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;https://reactjs.org&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#123;reactLogo&#125;</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;logo react&quot;</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">&quot;React logo&quot;</span> /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Vite + React<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;card&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount((count) =&gt; count + 1)&#125;&gt;</span><br><span class="language-xml">          count is &#123;count&#125;</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">          Edit <span class="hljs-tag">&lt;<span class="hljs-name">code</span>&gt;</span>src/App.jsx<span class="hljs-tag">&lt;/<span class="hljs-name">code</span>&gt;</span> and save to test HMR</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;read-the-docs&quot;</span>&gt;</span></span><br><span class="language-xml">        Click on the Vite and React logos to learn more</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>而在 App.jsx 中，则是通过 App 函数，返回了一段 jsx，这里面就是实际上描述页面的内容。</p><p>这里稍微岔开下话题，React 中通过首字母是否为大写来判断一个函数是组件还是普通函数，所以这里的 App() 函数首字母是大写的。</p><h3 id="一切的开始第一个组件-hello-world">一切的开始，第一个组件 &amp;&amp; Hello, World!</h3><p>当然对于我们这样的萌新而言，脚手架里提供的代码也是有点难懂。。。为了学习起见，我们需要对项目中的代码做一些调整。</p><p>具体的调整如下：</p><ol type="1"><li><p>src 目录下仅保留 main.jsx 和 App.jsx ，其余文件全部删除。</p></li><li><p>删除 main.jsx 中的不需要的 import 语句，直至代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react-dom/client&quot;</span>;<br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./App&quot;</span>;<br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;root&quot;</span>)).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>);<br></code></pre></td></tr></table></figure></li><li><p>删除 App.jsx 中的大部分语句，直至代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure></li></ol><p>之后我们所有的操作就只在 App.jsx 中进行，方便管理。当然实际的项目开发并不会像我们这样乱搞，大概率是会将不同的组件拆分到不同的文件中，不然想想看单文件几万行的屎山项目，对于开发者来说简直就是人间地狱。</p><p>OK,我们现在来写我们的第一个组件，我们希望这个组件应该能够渲染一段文本，其内容为 “Hello, World!”。</p><p>参考代码如下</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Hello</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>Hello, World!<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后我们在 App() 组件中将其实例化。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Hello</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Hello</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>渲染效果如图</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/%E7%AE%80%E5%8D%95%E7%BB%84%E4%BB%B6.png" alt="简单组件" /><figcaption aria-hidden="true">简单组件</figcaption></figure><p>这里有个有趣的地方，当我们创建了一个组件并想要在其他地方的 jsx 里面使用的时候，既可以写成自闭合标签，也可以写成普通的标签。</p><p>也就是说，既可以写成 &lt;Hello&gt;&lt;/Hello&gt;, 也可以写成 &lt;Hello/&gt; 。</p><h3 id="组件传参顺带渲染点别的">组件传参，顺带渲染点别的</h3><p>一个只能渲染 "Hello, World!" 的组件是没有前途的。至少得让他渲染点别的，至少得让他根据我们传入的参数渲染点什么出来。</p><p>这里整个简单的例子，就让我们的组件渲染一段根据参数拼接的文字，就在传入的参数（字符串）尾部加上 “，我好喜欢你啊”，比如给我们的 &lt;Love/&gt; 组件传入一个参数 “嘉然” ，就会渲染成 “嘉然，我好喜欢你啊”。</p><p>参考完整代码如下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Love</span> <span class="hljs-attr">love</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">嘉然</span>&quot;&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Love</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.love + &quot;,我好喜欢你啊&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><h4 id="表达式语法">表达式语法</h4><p>这里又引入了几个新语法，比如这个大括号，看起来很奇怪还显得很多余，难道就不能把它省略掉吗？</p><p>事实上，这里的大括号表示的是表达式的意思，大括号框住的内容是一个需要计算的表达式，如果省略掉大括号，div 标签内的内容则会直接被转义成字符串。</p><p>也就是说如果我们写成下面的形式，渲染的内容就根本不会是我们想要的。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/%E9%94%99%E8%AF%AF%E7%9A%84%E6%B8%B2%E6%9F%93.png" alt="错误的渲染" /><figcaption aria-hidden="true">错误的渲染</figcaption></figure><p>...就像图片里演示的那样。</p><p>加上大括号后，结果就正常了，我们甚至还能多整几行。</p><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/%E6%AD%A3%E7%A1%AE%E7%9A%84%E6%B8%B2%E6%9F%93.png" alt="正确的渲染" /><figcaption aria-hidden="true">正确的渲染</figcaption></figure><h4 id="props">props</h4><p>另一个奇怪的语法是这个 props ，很显然我们的参数传递都是通过 props 实现的。这个词是 properties 的缩写，意思就是属性，怎么感觉说了和没说的一样。。</p><p>在 jsx 中写标签时，我们往里面传入的参数则会被包装成一个 js 对象，也就是 props ，所以在组件函数中想要使用外界传入的参数时，只要使用 props 里的参数即可。</p><p>也就是说，如果要传递不可变的参数给组件，在 jsx 里面写标签的时候在标签里写上 " 参数名={参数值} " 就可以了，使用时用 " props.参数名 " 即可访问到所需要的参数。</p><p>至于为什么是不可变的参数，这是个大坑，之后到类组件和 hocks 的时候再细聊。</p><p>这种写法看起来挺酷炫的，但是捏，当组件需要的参数变的多起来且参数名称变的越来越长的时候就有点蛋疼了，因为憨憨的编辑器压根不提示！而且如果写了错误的参数名称，也不会报错，实际渲染时候那个 prop 的值则会变成 undefined 。这挺蠢的。。因为这种错误不必要非得在运行时才能发现。至于解决方式，后面我们在把 react 基础的一些玩意儿搞定后就会介绍一个屌炸天的新玩意儿，typescript，通过类型约束就可以很好的解决这种问题，甚至编辑器的提示也更有劲了，自动补全一口气能上三楼了。</p><h4 id="解构赋值语法">解构赋值语法</h4><p>可是现在学 ts 还是有点太远了，所以这里有一种简单的技巧也可以让编辑器提供更好的自动补全，即使用 es6 中新增加的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment">解构赋值语法</a>。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ABC</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">我</span>&quot;&#125; <span class="hljs-attr">birthday</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">我的生日</span>&quot;&#125; /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">ABC</span>(<span class="hljs-params">&#123; name, birthday &#125;</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;name + &quot;的生日是&quot; + birthday&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><figure><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC.png" alt="解构赋值" /><figcaption aria-hidden="true">解构赋值</figcaption></figure><p>虽然是一段废话代码，但是这个技巧确实还不错。</p><h3 id="条件渲染">条件渲染</h3><p>在使用组件时经常会需要根据指定的条件来渲染特定组件，所以我们会希望在在渲染时增加一些判断逻辑。</p><h4 id="包装组件和判断逻辑">包装组件和判断逻辑</h4><p>由于 jsx 里面只能插入表达式，所以直接写判断是不行的，所以我们可以将判断语句和想要分别展示的组件放置到一个新组件中来处理。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">M1</span> <span class="hljs-attr">choice</span>=<span class="hljs-string">&#123;true&#125;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">M1</span> <span class="hljs-attr">choice</span>=<span class="hljs-string">&#123;false&#125;</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">M1</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">if</span> (props.<span class="hljs-property">choice</span> === <span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/08/01/20220801-155315.png" /></p><h4 id="三目运算符">三目运算符</h4><p>包装成另一个组件在处理复杂逻辑时很有用的，但是绝大多数情况下我们可能只是需要一个二选一的判断， A 或 B，渲染或不渲染，这种情况下三目运算符就是一个很好的选择。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> flag = <span class="hljs-literal">true</span>;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;flag ? <span class="hljs-tag">&lt;<span class="hljs-name">What</span> <span class="hljs-attr">what</span>=<span class="hljs-string">&#123;</span>&quot;???&quot;&#125; /&gt;</span> : null&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;flag ? null : <span class="hljs-tag">&lt;<span class="hljs-name">What</span> <span class="hljs-attr">what</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">not</span> <span class="hljs-attr">empty</span>&quot;&#125; /&gt;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;!flag ? <span class="hljs-tag">&lt;<span class="hljs-name">What</span> <span class="hljs-attr">what</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">false</span>&quot;&#125; /&gt;</span> : <span class="hljs-tag">&lt;<span class="hljs-name">What</span> <span class="hljs-attr">what</span>=<span class="hljs-string">&#123;</span>&quot;<span class="hljs-attr">true</span>&quot;&#125; /&gt;</span>&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">What</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>&#123;props.what&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/08/01/20220801-170359.png" /></p><p>就像代码里面演示的那样，当我们遇到渲染、不渲染二选一这种逻辑时，直接在不渲染时返回 null 即可。</p><h3 id="处理列表">处理列表</h3><p>在页面的构建中，一种很常见的写法是将 js 中的列表或者其他可迭代的结构转换成对应的组件结构。比如说将后端返回的一组文章提要转换为 dom 树上的一个无序列表，接下来我们来处理这种情形。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;学生&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">24</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李田所&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">19.19</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;野兽&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">8.1</span>,<br>    &#125;,<br>  ];<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;data.map((i) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i.year.toString()&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;i.name&#125;</span> <span class="hljs-attr">year</span>=<span class="hljs-string">&#123;i.year&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Item</span>(<span class="hljs-params">props</span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>name: &#123;props.name&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>year: &#123;props.year&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/08/12/eb6ed08d524b46a14d80c5737468a3b2-image-20220812072335406-d7534f.png" /></p><p>虽然结果是差不多的，但是控制台却有个警告，</p><p>这里的警告说的是列表的每一个子元素都需要有一个 "key" 属性。</p><p>原因解释起来比较复杂，深入了解的话需要对 vdom 和 dif 算法有一定认识，简单概括就是无 key 时使用的 dif 算法比有 key 时的更加没有效率。</p><p>所以我们在 App() 里补充上 key，这里我们就将 key 设置为列表元素的 .year 属性。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> data = [<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;学生&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">24</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;李田所&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">19.19</span>,<br>    &#125;,<br>    &#123;<br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;野兽&quot;</span>,<br>      <span class="hljs-attr">year</span>: <span class="hljs-number">8.1</span>,<br>    &#125;,<br>  ];<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">className</span>=<span class="hljs-string">&quot;App&quot;</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        &#123;data.map((i) =&gt; (</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">Item</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&#123;i.year.toString()&#125;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#123;i.name&#125;</span> <span class="hljs-attr">year</span>=<span class="hljs-string">&#123;i.year&#125;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">Item</span>&gt;</span></span><br><span class="language-xml">        ))&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>另外一点值得注意的，这里的 key 属性只加在组件被调用时，也就是这里的 App() 组件，而不是直接加在 Item() 里面。</p><h2 id="管理内部数据">管理内部数据</h2><p>在上个章节中我们使用的都是无内部状态的的组件，组件无法保存数据而是根据外部的数据源渲染，在这个章节中我们将会更进一步的研究讨论如何在组件中保存状态。</p><h3 id="类组件和生命周期方法">类组件和生命周期方法</h3><p>在面向对象中，遇到这种需要内部数据的情形时，一般都是将数据结构和其他函数封装成一个类，使用时只需实例化对象即可。得益于 es6 引入的类语法，react 中也可以实现类似的操作。</p><p>这里作为示例，我们将创建一个简单的计时器，用于演示类组件的使用方法，以下为 App.jsx 的内容。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Clock</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  state = &#123; <span class="hljs-attr">date</span>: <span class="hljs-literal">null</span>, <span class="hljs-attr">timer</span>: <span class="hljs-literal">null</span> &#125;;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>() &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">componentDidMount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span> = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">tick</span>(), <span class="hljs-number">1000</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">componentWillUnmount</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">clearInterval</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">timer</span>);<br>  &#125;<br><br>  <span class="hljs-title function_">tick</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123;<br>      <span class="hljs-attr">date</span>: <span class="hljs-keyword">new</span> <span class="hljs-title class_">Date</span>(),<br>    &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Hello, world!<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>It is &#123;this.state.date.toLocaleTimeString()&#125;.<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>注意我们创建的类组件需要继承 React.Component ,所以需要预先 import 一下。</p><p>首先我们创建一个继承自 React.Component 的空组件。并添加 constructor 方法，这个方法会调用 super(props) 调用父类的构造函数。</p><p>然后为我们的类添加初始化的内部状态，即 state ，注意这一步并不是必需的，这样做的目的主要是为了方便阅读与增强编辑器的提示能力。</p><p>接下来创建一个 render 方法，这个函数会返回一段 jsx 表达式，也就是我们之前在函数式组件中写的返回值。</p><p>然后我们创建 tick 方法，这个方法会更新 state 中的字段。</p><p>这里就碰到了 react 中比较奇怪的一个特性，即<strong>不变性</strong>，也就是我们这里并不能直接修改 state 中的 date 属性，而是得使用 setState 方法重新给 state 赋值，setState 方法则只会基于我们传入的对象的字段去更新 state，state 的其余字段则会与原先一致。</p><p>由于我们希望组件在被创建后每秒都调用一次 tick 方法，所以我们需要一个生命周期方法，生命周期方法指的是在组件挂载、更新、销毁时会调用的方法。</p><p>所以我们在 componentDidMoun 方法中通过 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/setInterval">setInterval</a> 函数每隔一秒就调用一次 tick 方法，注意在组件销毁时清除掉 setInterval 返回的 interval ID ，所以我们在 componentWillUnmount 方法中调用 clearInterval 函数清除掉 interval ID。</p><p>除了我们刚才介绍的两个生命周期方法，其实还有一些其他的生命周期方法，关于完整的生命周期方法和生命周期函数的执行顺序，可以参考<a href="https://zh-hans.reactjs.org/docs/react-component.html">这篇</a>文档。</p><p>听着貌似挺乱的。。。事实也确实如此，相较于函数组件的简洁形式，类组件明显要更复杂些，但是有没有一种更加优雅的方法呢？当然是是有的！在后几章我们会接触到如何在函数组件中使用 hocks 管理内部数据。</p><h3 id="回调函数与-react-事件处理">回调函数与 React 事件处理</h3><p>不会响应用户交互的组件是没有前途的！在这个小节我们将会介绍在组件中如何使用回调函数更新 state ，并学习使用 react 中的事件处理函数。</p><h4 id="回调函数和蛋疼的-this">回调函数和蛋疼的 this</h4><p><a href="https://en.wikipedia.org/wiki/Callback_(computer_programming)">回调函数</a>，一种非常常见的设计模式，在使用 react 组件时，有时候我们会希望某些组件接受一个函数并在适时的时候调用，这时候就是回调操作大展身手的机会。接下来我们来看一个例子怎么使用回调创建一个计数器的框架。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.add()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>好吧。这个例子可能有些剧透，比如 props 里面那个奇怪的 onClick ，总之先知道这个 onClick 会在组件被点击时调用传入的函数就行了。</p><p>我们来看代码里面的其他部分，和在上一节里面介绍的类组件一样，我们同样为其提供了 constructor 和 render 函数，然后定义一个 add 函数用于更新 state，然后传递一个奇怪的箭头函数给 onClick 做回调，当按钮被点击时即会触发。</p><p>这里的写法其实很奇怪，为什么不直接传函数名而是传递一个箭头函数呢？这里就是 js 屎山特性的一个蛋疼问题，臭名昭著的 this 绑定问题。具体内容可以参考 mdn 的<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/this">这篇文章</a>以及 react 文档中关于 jsx 编译为 js 代码的内容。</p><p>如果我们写成如下写法</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked!&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this =&quot;</span>);<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>&#125;<br><br><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>在点击按钮后</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/08/24/5a0bd68c5f9bc0628b79fcebd6a1edd6-image-20220824083527832-b63c32.png" /></p><p>就会发现 add 函数的 this 绑定到了 undefined 上，也就不可能更新 state 内容了。</p><p>而<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions">箭头函数</a>并没有自己的 this，所以传递箭头函数给 onClick 的时候, add 的 this 则就处于正确的上下文环境中了。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.add()&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img@main/blog-images/2022/08/24/f90b05f272cef28645af7b01596e9826-image-20220824084639323-41c83d.png" /></p><h4 id="茴字的四种写法">茴字的四种写法</h4><p>其实除了上述直接传递箭头函数的写法外，还有几种其他的写法。</p><h5 id="公有类字段绑定箭头函数传参提供字段名称推荐">1.公有类字段绑定箭头函数，传参提供字段名称（推荐）</h5><p>具体细节可以参考<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Classes/Public_class_fields">这份文档</a>，这也是推荐的一种写法，可以避免在调用时创建多余的箭头函数。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  &#125;<br><br>  add = <span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked!&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this =&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-bind-手动绑定-this">2.使用 bind 手动绑定 this</h5><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked!&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this =&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;this.add.bind(this)&#125;</span>&gt;</span>+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注意 bind 返回的是一个函数，所以这么写是可以的。</p><h5 id="使用-call-手动绑定-this">3.使用 call 手动绑定 this</h5><p>真的会有人这么写吗？</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Counter</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">count</span>: <span class="hljs-number">0</span> &#125;;<br>  &#125;<br><br>  <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;Clicked!&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;this =&quot;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">count</span>: <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">count</span> + <span class="hljs-number">1</span> &#125;);<br>  &#125;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>Count: &#123;this.state.count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> this.add.call(this)&#125;&gt;+1<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="react-的事件处理函数">react 的事件处理函数</h4><p>在刚才我们实现的计数器组件中已经用到了 react 中的事件处理函数，也就是我们传递给 button 的 onClick 属性，正如其名，这个事件处理函数会在组件被点击时触发。 此外常见的事件处理函数还有 onFocus, onKeyPress 等等。完整的列表可以参考 react 文档<a href="https://zh-hans.reactjs.org/docs/events.html">提供的部分</a>。 另外就是在子组件处理事件时，有时候需要避免父组件（冒泡）或者自身的默认行为。 这里采用表单组件作为例子，当 submit 时会触发页面刷新，我们尝试在组件中阻止默认行为。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Form</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleSubmit</span>(<span class="hljs-params">e</span>) &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;You clicked submit.&quot;</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">            <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>   &#123;&quot; &quot;&#125;</span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>  );<br>&#125;<br></code></pre></td></tr></table></figure><p>这里 onSubmit 绑定到了一个接受合成事件 e 的函数，在 handleSubmit 中调用 e 的 preeventDefault 方法阻止其默认行为。 当然就像上一节中介绍的各种写法一样，也可以改写成类组件的形式。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Form</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>  &#125;<br><br>  handleSubmit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;You clicked submit.&quot;</span>);<br>  &#125;;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">                <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>Submit<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>     &#123;&quot; &quot;&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="事件处理传递额外参数">事件处理传递额外参数</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Hello</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;(e)</span> =&gt;</span> this.handleClick(e, &quot;click button&quot;)&#125;&gt;</span><br><span class="language-xml">          button</span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>    );<br>  &#125;<br><br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>  &#125;<br><br>  handleClick = <span class="hljs-function">(<span class="hljs-params">e, msg</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(msg);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(e);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="受控组件">受控组件</h3><p>在使用组件去创建保存数据并对输入数据进行渲染的应用时，一种很常见的的手法是使用受控组件，即在父组件中保存状态，子组件根据父组件的 state 进行渲染，当需要进行状态变更时，子组件调用父组件传入的函数来更改状态。</p><pre><code class=" mermaid">graph TDA[父组件] --&gt;|数据流| B[子组件]B -.-&gt; |控制流| A</code></pre><p>我们接下来写一个表单的例子来演示一下。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">PackagedForm</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PackagedForm</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_ inherited__">React.Component</span> &#123;<br>  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">props</span>) &#123;<br>    <span class="hljs-variable language_">super</span>(props);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = &#123; <span class="hljs-attr">input</span>: <span class="hljs-string">&quot;&quot;</span> &#125;;<br>  &#125;<br><br>  handleChange = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-title function_">setState</span>(&#123; <span class="hljs-attr">input</span>: e.<span class="hljs-property">target</span>.<span class="hljs-property">value</span> &#125;);<br>  &#125;;<br><br>  handleSubmit = <span class="hljs-function">(<span class="hljs-params">e</span>) =&gt;</span> &#123;<br>    <span class="hljs-title function_">alert</span>(<span class="hljs-string">&quot;提交的名字: &quot;</span> + <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span>.<span class="hljs-property">input</span>);<br>    e.<span class="hljs-title function_">preventDefault</span>();<br>  &#125;;<br><br>  <span class="hljs-title function_">render</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">onSubmit</span>=<span class="hljs-string">&#123;this.handleSubmit&#125;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">          名字:</span><br><span class="language-xml">          <span class="hljs-tag">&lt;<span class="hljs-name">input</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">value</span>=<span class="hljs-string">&#123;this.state.input&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">            <span class="hljs-attr">onChange</span>=<span class="hljs-string">&#123;this.handleChange&#125;</span></span></span><br><span class="hljs-tag"><span class="language-xml">          /&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;/<span class="hljs-name">label</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;提交&quot;</span> /&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span></span><br>    );<br>  &#125;<br>&#125;<br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>在这里，表单本身并不会保存数据，所有的数据都是保存在我们自定义的组件的 state 中，就像刚才那张流程图描述的一样。</p><h2 id="hocks">hocks</h2><p>hocks 是 react 16.8 新引进的一种功能，可以不使用 class 写法也能保存 state 和管理组件的生命周期。</p><h3 id="state-hook">State Hook</h3><p>state hock 提供了一个简单的方式来管理 state 接下来我们创建一个简单的计数器来使用 state hock 。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span>count: &#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount(count + 1)&#125;&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>是不是很简单？useState 函数返回了一个数据，通过数组解构语法把其内容物绑定到 count 和 setCount 上，然后在组件中直接使用 count 即可，如果需要更新，使用 setCount 然后传入用于更新的表达式即可。</p><p>顺带一提，setCount 中间也可以传入一个函数用于更新 state 。 如果需要多个内部状态，重复多次使用 useState 即可。</p><p>useState 使用起来非常类似于其他语言中实例化对象的静态变量，在组件的生命周期中这些 state 只会被初始化一次，然后被更新和使用。</p><h3 id="副作用和-efect-hock">副作用和 Efect Hock</h3><p>好吧，到这里我们不得不稍微提及一点函数式相关的内容。 关于纯函数和副作用，详细可以参考<a href="https://en.wikipedia.org/wiki/Pure_function">这篇 wiki</a>。</p><p>简单来说纯函数就是输出只和输入唯一绑定且不影响其他状态，如全局变量等的函数。</p><p>副作用就是非纯函数调用时会产生的影响，包括不限于 I/O，全局变量的写。</p><p>effect hock 就是一类用于执行副作用相关操作的 hock，数据获取，设置订阅以及手动更改 React 组件中的 DOM 都属于副作用。</p><p>事实上 effect hock 的用法相当多样，react 团队基本上讲一大堆原先的生命周期方法都塞进 effect hock 里面了。。。我觉得这样挺蠢的。接下来我们简单将各个用法分类介绍下。</p><h4 id="对应组件挂载或者更新时">对应组件挂载或者更新时</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>);<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount((i) =&gt; i + 1)&#125;&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>注意，这里的 useEffect 会在开始时调用两次传入的函数，这并不是什么 bug ，在生产环境发布时并不会有上述行为，详细信息请自行使用搜索引擎，在此不再叙述过多。</p><h4 id="对应组件卸载时清除副作用">对应组件卸载时（清除副作用）</h4><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">Box</span> /&gt;</span></span>;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Box</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [flag, setFlag] = <span class="hljs-title function_">useState</span>(<span class="hljs-literal">true</span>);<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      &#123;flag ? <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span> : null&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setFlag(!flag)&#125;&gt;&#123;flag ? &quot;on&quot; : &quot;off&quot;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [count, setCount] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`clicked <span class="hljs-subst">$&#123;count&#125;</span> times`</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;unmounted&quot;</span>);<br>    &#125;;<br>  &#125;);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h2</span>&gt;</span>&#123;count&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setCount((i) =&gt; i + 1)&#125;&gt;click me<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>在这里，当组件 Counter 被卸载时，会调用我们传给 useEffect 的函数，也就是在控制台打印消息 "unmounted" 。</p><h4 id="追踪依赖变化">追踪依赖变化</h4><p>有时候我们只希望在某些变量变化时才使用 useEffect，要实现这种操作其实很简单，只要在 useEffect 的第二个参数中传入需要追踪的参数的列表即可。</p><figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs jsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span>, &#123; useState &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><span class="hljs-keyword">import</span> &#123; useEffect &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;react&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">App</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">Counter</span> /&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Counter</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> [button0, setButton0] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [button1, setButton1] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br>  <span class="hljs-keyword">const</span> [button2, setButton2] = <span class="hljs-title function_">useState</span>(<span class="hljs-number">0</span>);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;you clicked button0&quot;</span>), [button0]);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;you clicked button1&quot;</span>), [button1]);<br><br>  <span class="hljs-title function_">useEffect</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;you clicked button2&quot;</span>), [button2]);<br><br>  <span class="hljs-keyword">return</span> (<br>    <span class="language-xml"><span class="hljs-tag">&lt;&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">        button0:&#123;button0&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> button1:&#123;button1&#125; <span class="hljs-tag">&lt;<span class="hljs-name">br</span> /&gt;</span> button2:&#123;button2&#125;</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setButton0(button0 + 1)&#125; key=&#123;&quot;button0&quot;&#125;&gt;</span><br><span class="language-xml">        button0: +1</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setButton1(button1 + 1)&#125; key=&#123;&quot;button1&quot;&#125;&gt;</span><br><span class="language-xml">        button1: +1</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">onClick</span>=<span class="hljs-string">&#123;()</span> =&gt;</span> setButton2(button2 + 1)&#125; key=&#123;&quot;button2&quot;&#125;&gt;</span><br><span class="language-xml">        button2: +1</span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/&gt;</span></span><br>  );<br>&#125;<br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> <span class="hljs-title class_">App</span>;<br></code></pre></td></tr></table></figure><p>注意，这里追踪的依赖项都是基本变量，假设你需要依赖项是一个引用类型，请不要这么写，有可能会出现不及时更新或者重复更新等 bug，解决方法在这里详细叙述的话可能不太合适，简单来说，使用第三方全局状态管理或者 useMemo 会是一个好主意。</p><h4 id="仅在挂载和销毁时调用">仅在挂载和销毁时调用</h4><p>这实际上是上一小节的小小拓展。。。只要把依赖数组填写为空数组即可，是不是很简单？</p><h3 id="custom-hock">Custom Hock</h3><p>todo...</p><h3 id="isthereanythingmore">isThereAnythingMore?</h3><p>hocks 事实上还有很多可以聊下去的话题。。。但是深入展开的话就不符合这篇记录的主旨了！这只是一篇关于 react 学习的小作品，更多的内容就交给 google 和 github 吧 :)</p><p>这里推荐几个还不错的学习资源。</p><ol type="1"><li><p><a href="https://zh-hans.reactjs.org/docs/hooks-reference.html#usememo">React 官网的 Hocks API 索引</a></p></li><li><p><a href="https://overreacted.io/zh-hans/a-complete-guide-to-useeffect/">dan_abramov 大佬的关于 effectHocks 的一篇长文</a></p></li></ol><h2 id="阶段性总结">阶段性总结</h2><p>在前几个章节里我们已经一起体验了 react 的核心概念，在后续的章节里我们将会更深入的步入基于 react 的前端开发，就像之前承诺的，学习 ts ，然后去使用一些第三方库。</p><p>相信我，这绝对会非常有趣的 ;)</p><h1 id="typescript">TypeScript</h1><p>在这个章节中我们将会介绍 ts 的基本语法和如何在 react 中使用 tsx 编写和使用组件<del>以及如何成为一名类型体操运动员</del>。 注意，我们不会详细的介绍所有概念，完整的介绍可以阅读<a href="https://www.typescriptlang.org/docs/handbook/basic-types.html">官方文档</a>。</p><h2 id="类型">类型</h2><h3 id="基本类型">基本类型</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">// 布尔值</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">flag</span>: <span class="hljs-built_in">boolean</span> = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ts采用后置类型标注</span><br><span class="hljs-keyword">let</span> anoutherFlag = <span class="hljs-literal">false</span>; <span class="hljs-comment">// ts也支持类型推断，所以绝大数情况下不需要手动标注类型</span><br><br><span class="hljs-comment">// number</span><br><span class="hljs-keyword">let</span> num = <span class="hljs-number">1.1</span><br><span class="hljs-keyword">const</span> <span class="hljs-built_in">number</span> = <span class="hljs-number">10</span> <span class="hljs-comment">// 你也可以使用 const 来声明一个不可变变量</span><br><br><span class="hljs-comment">// 字符串</span><br><span class="hljs-keyword">const</span> name = <span class="hljs-string">&quot;ooj&quot;</span><br><span class="hljs-keyword">const</span> favorite = <span class="hljs-string">&quot;chocolate&quot;</span><br><span class="hljs-keyword">let</span> s = <span class="hljs-string">`<span class="hljs-subst">$&#123;name&#125;</span> &#x27;s favorite food is <span class="hljs-subst">$&#123;favorite&#125;</span>`</span> <span class="hljs-comment">//模板字符串</span><br><br><span class="hljs-comment">// void</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>): <span class="hljs-built_in">void</span> &#123;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br><span class="hljs-comment">// 无返回值的函数的返回类型即为 void</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">res</span>: <span class="hljs-built_in">void</span> = <span class="hljs-title function_">f</span>() <br><br><span class="hljs-comment">// null 和 undefined</span><br><span class="hljs-comment">// 任何类型的子类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">i</span>:<span class="hljs-built_in">number</span> = <span class="hljs-number">1</span><br>i = <span class="hljs-literal">null</span><br>i = <span class="hljs-literal">undefined</span><br><br><span class="hljs-comment">// any</span><br><span class="hljs-comment">// 加上这个, ts 就变回了 js</span><br><br></code></pre></td></tr></table></figure><h3 id="联合类型union-types">联合类型（Union Types）</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//声明联合类型</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">n</span>: <span class="hljs-built_in">string</span>|numbrt = <span class="hljs-string">&quot;one&quot;</span><br>n = <span class="hljs-number">1</span><br><br><span class="hljs-comment">//当上下文无法推断出具体类型时，访问属性或者方法时只能访问公共属性、方法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Number</span>&gt;|<span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Number</span>&gt;|<span class="hljs-built_in">string</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> len = (i : <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Number</span>&gt; | <span class="hljs-built_in">string</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> i.<span class="hljs-property">length</span><br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a: &quot;</span> + <span class="hljs-title function_">len</span>(a));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b: &quot;</span> + <span class="hljs-title function_">len</span>(b));<br></code></pre></td></tr></table></figure><h3 id="类型别名">类型别名</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//上一小节的联合类型写了很多扽重复代码，通过类型别名可以更好的表述我们需要的类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Number</span>&gt;|<span class="hljs-built_in">string</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">a</span>: <span class="hljs-title class_">MyType</span> = <span class="hljs-string">&quot;hi&quot;</span>;<br><span class="hljs-keyword">let</span> <span class="hljs-attr">b</span>: <span class="hljs-title class_">MyType</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];<br><span class="hljs-keyword">const</span> len = (<span class="hljs-attr">i</span>: <span class="hljs-title class_">MyType</span>): <span class="hljs-function"><span class="hljs-params">number</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> i.<span class="hljs-property">length</span>;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;a: &quot;</span> + <span class="hljs-title function_">len</span>(a));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;b: &quot;</span> + <span class="hljs-title function_">len</span>(b));<br></code></pre></td></tr></table></figure><h3 id="数组">数组</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//一般写法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">numbers</span>: <span class="hljs-built_in">number</span>[] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br><span class="hljs-comment">//泛型写法</span><br><span class="hljs-keyword">let</span> <span class="hljs-attr">myNumbers</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">number</span>&gt; = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br></code></pre></td></tr></table></figure><h3 id="函数">函数</h3><figure class="highlight ts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs ts"><span class="hljs-comment">//函数的类型</span><br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">F1</span> = <span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">void</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">hi</span>: <span class="hljs-variable constant_">F1</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;hi&quot;</span>)<br>&#125;<br><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">F2</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-attr">sub</span>: <span class="hljs-variable constant_">F2</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> a - b;<br>&#125;<br><br><span class="hljs-comment">//函数的类型标注</span><br><span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span> = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>) =&gt;</span>&#123;<br><span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">mul</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span></span>): <span class="hljs-built_in">number</span> &#123;<br>  <span class="hljs-keyword">return</span> a * b;<br>&#125;<br><br><span class="hljs-comment">//可选参数</span><br><span class="hljs-keyword">type</span> f = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>?: <span class="hljs-built_in">number</span></span>) =&gt;</span> <span class="hljs-built_in">number</span><br><br><span class="hljs-keyword">const</span> <span class="hljs-attr">add</span>: f = <span class="hljs-function">(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span>, <span class="hljs-attr">b</span>?: <span class="hljs-built_in">number</span></span>)  =&gt;</span> &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> b ===<span class="hljs-string">&quot;undefined&quot;</span>) &#123;<br>    <span class="hljs-keyword">return</span> a;<br>  &#125;<br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-comment">//参数默认值</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, <span class="hljs-attr">b</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span></span>) &#123;<br>  <span class="hljs-comment">//注意此时 add 的类型变成了 (a?: number, b?: number) =&gt; number</span><br>  <span class="hljs-keyword">return</span> a + b;<br>&#125;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>());<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>));<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>))<br><br><span class="hljs-comment">//剩余参数</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span>(<span class="hljs-params"><span class="hljs-attr">a</span>: <span class="hljs-built_in">number</span> = <span class="hljs-number">0</span>, ...<span class="hljs-attr">args</span>: <span class="hljs-built_in">number</span>[]</span>) &#123;<br>  <span class="hljs-keyword">let</span> s = a;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> i <span class="hljs-keyword">of</span> args) &#123;<br>    s += i;<br>  &#125;<br>  <span class="hljs-keyword">return</span> s;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="类型断言">类型断言</h3><p>类型断言可以欺骗编译器，让编译器认为某个变量的类型为另一个类型。 类型断言可以有两种写法 as "你想要的类型" 或者 &lt;"你想要的类型"&gt;"变量" ，我们推荐前一种写法，否则在编写 tsx 时可能会产生语法歧义。 这里我举一个实际开发中会用到断言的地方。 <figure class="highlight tsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs tsx"><span class="hljs-keyword">import</span> <span class="hljs-title class_">React</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">ReactDOM</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;react-dom/client&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">App</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./App&#x27;</span><br><span class="hljs-keyword">import</span> <span class="hljs-string">&#x27;./index.css&#x27;</span><br><br><span class="hljs-title class_">ReactDOM</span>.<span class="hljs-title function_">createRoot</span>(<span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLElement</span>).<span class="hljs-title function_">render</span>(<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">App</span> /&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">React.StrictMode</span>&gt;</span></span><br>)<br></code></pre></td></tr></table></figure> getElementById 方法的返回值为 HTMLElement | null ，但是我们并不需要处理 null 的情况。。因为如果在根节点处获取的是 null , 很可能意味着发生了更大的问题，断言成 HTMLElement ，然后真出问题时让其在运行时崩溃可能是更好的一种选择。</p>]]></content>
    
    
    <categories>
      
      <category>前端</category>
      
    </categories>
    
    
    <tags>
      
      <tag>react</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>算法课设</title>
    <link href="/2022/06/24/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/"/>
    <url>/2022/06/24/%E7%AC%94%E8%AE%B0/%E7%AE%97%E6%B3%95%E8%AF%BE%E8%AE%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="圈乘运算问题">圈乘运算问题</h1><h2 id="问题描述">问题描述</h2><p>定义 <span class="math inline">\(X@Y\)</span> = 十进制整数 <span class="math inline">\(X\)</span> 的各位数字之和 * 十进制整数 <span class="math inline">\(Y\)</span> 的最大数字 + <span class="math inline">\(Y\)</span> 的最小数字</p><p>对于给定的 <span class="math inline">\(X, K\)</span> ，计算出由 <span class="math inline">\(X, @\)</span> 组成的表达式值为 <span class="math inline">\(K\)</span> 的表达式最少需要多少个 <span class="math inline">\(@\)</span> 运算</p><h2 id="算法设计">算法设计</h2><p>容易得放缩式 <span class="math display">\[\displaylines{X@Y \le 81 \times N + 9\\where:\ N -1 &lt; lg(X) \le N}\]</span> 此式是容易证明的</p><p>注意到 <span class="math inline">\(N\)</span> 代表着 <span class="math inline">\(X\)</span> 的位数，则显然有十进制整数 <span class="math inline">\(X\)</span> 的各位数字之和小于 <span class="math inline">\(9N\)</span> ，又十进制中每一位最大值为 <span class="math inline">\(9\)</span> ，故上式得证。</p><p>当取最小位为 <span class="math inline">\(0\)</span> ,最大位为 <span class="math inline">\(1\)</span> 时，同理可证明其下界为</p><p><span class="math display">\[X@Y \ge X\]</span></p><p>定义 <span class="math inline">\(g(X,\ K)\)</span> 为计算最小 <span class="math inline">\(@\)</span> 数量的函数，<span class="math inline">\(G[i]=g(X, i)\)</span> 则可得其状态转移方程为</p><p><span class="math display">\[\displaylines{G[i+j]=min\{G[i+j],\ G[i]+G[j]+1\}\\where:\ X \le i,j \le K}\]</span> 综上，参考cpp代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;algorithm&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;cstring&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> i32 int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> i64 long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> u128 unsigned long long</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> u32 unsigned int</span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><span class="hljs-type">const</span> i32 MAXN = (<span class="hljs-type">int</span>) <span class="hljs-number">5e2</span>;<br><span class="hljs-comment">// const i64 M = 1e10;</span><br><span class="hljs-type">const</span> <span class="hljs-keyword">auto</span> L = <span class="hljs-number">0x3f</span>;<br><br>i64 G[MAXN];<br>i64 X, K;<br><br><span class="hljs-function">i64 <span class="hljs-title">f</span> <span class="hljs-params">(i64 X, i64 Y)</span> </span>&#123;<span class="hljs-comment">//X@Y运算</span><br>    i64 numX = <span class="hljs-number">0</span>, mxY = <span class="hljs-number">0</span>, mnY = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">while</span> (X) &#123;<br>        numX += X % <span class="hljs-number">10</span>;<br>        X /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">while</span> (Y != <span class="hljs-number">0</span>) &#123;<br>        mxY = <span class="hljs-built_in">max</span> (mxY, Y % <span class="hljs-number">10</span>);<br>        mnY = <span class="hljs-built_in">min</span> (mnY, Y % <span class="hljs-number">10</span>);<br>        Y /= <span class="hljs-number">10</span>;<br>    &#125;<br>    <span class="hljs-keyword">return</span> numX * mxY + mnY;<br>&#125;<br><br><span class="hljs-function">i64 <span class="hljs-title">get_lim</span> <span class="hljs-params">(i64 X, i64 K)</span> </span>&#123;<span class="hljs-comment">//获取上界</span><br>    <span class="hljs-keyword">auto</span> num = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span> (X) &#123;<br>        X /= <span class="hljs-number">10</span>;<br>        num++;<br>    &#125;<br>    i64 lim = <span class="hljs-built_in">max</span> (num, <span class="hljs-number">2</span>) * <span class="hljs-number">81</span> + <span class="hljs-number">9</span>;<br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">max</span>(lim, K);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span> <span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-built_in">memset</span> (G, L, <span class="hljs-built_in">sizeof</span> (G));<br>    cin &gt;&gt; X &gt;&gt; K;<br>    <span class="hljs-keyword">auto</span> lim = <span class="hljs-built_in">get_lim</span> (X, K);<br>    G[<span class="hljs-built_in">f</span> (X, X)] = <span class="hljs-number">1</span>;<br>    G[X] = <span class="hljs-number">0</span>;<br><br>    <span class="hljs-keyword">if</span> (X &gt; K) &#123;<br>        <span class="hljs-keyword">goto</span> error;<br>    &#125;<br><br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> i = X; i &lt;= lim; ++i) &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">auto</span> j = X; j &lt;= lim; ++j) &#123;<br>            <span class="hljs-keyword">if</span> (G[i] &lt; L &amp;&amp; G[j] &lt; L &amp;&amp; G[<span class="hljs-built_in">f</span> (i, j)] &gt; G[i] + G[j] + <span class="hljs-number">1</span>) &#123;<span class="hljs-comment">//i@j到S的运算次数更少,则更新</span><br>                G[<span class="hljs-built_in">f</span> (i, j)] = G[i] + G[j] + <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (G[K] &lt; L) &#123;<br>        cout &lt;&lt; G[K] &lt;&lt; endl;<br>        <span class="hljs-comment">// for (auto p = X; p &lt;= K; ++p) &#123;</span><br>        <span class="hljs-comment">//     cout &lt;&lt; p &lt;&lt; &quot;:&quot; &lt;&lt; G[p] &lt;&lt; &quot; &quot;;</span><br>        <span class="hljs-comment">// &#125;</span><br>        <span class="hljs-comment">// cout &lt;&lt; endl;</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>    error:<br>        cout &lt;&lt; <span class="hljs-string">&quot;error&quot;</span> &lt;&lt; endl;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>课设</category>
      
    </categories>
    
    
    <tags>
      
      <tag>算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>图片隐写-everlasting_night</title>
    <link href="/2022/05/30/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99-everlasting-night/"/>
    <url>/2022/05/30/%E9%A2%98%E8%A7%A3/%E5%9B%BE%E7%89%87%E9%9A%90%E5%86%99-everlasting-night/</url>
    
    <content type="html"><![CDATA[<p>题目给了一张图片，看起来平平无奇的。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-191800.png" /></p><p>用 binwalk 看下，里面似乎藏了个压缩包。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-191951.png" /></p><p>用16进制编辑器打开看下，在文件的尾端有一串奇怪的HEX。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-192346.png" /></p><p>先记下来，之后再看下。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">FB</span> <span class="hljs-number">3</span>E FC E4 CE AC <span class="hljs-number">2</span>F <span class="hljs-number">54</span> <span class="hljs-number">45</span> C7 AE <span class="hljs-number">17</span> E3 E9 <span class="hljs-number">69</span> AB<br></code></pre></td></tr></table></figure><p>再用 stegsolve 看看，注意到右下角有竖立的奇怪的黑色斑块，故用列模式查看。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-193003.png" /></p><p>又是一串奇怪的乱码，同样记下来。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">f78dcd383f1b574b<br></code></pre></td></tr></table></figure><p>由于题目提供的格式为png，所以有可能是通过lsb技术在像素上写入了额外的信息。</p><p>所以使用 python 将其解码并使用 binwalk 查看。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">python2 lsb.py extract everlasting_night.png out.txt f78dcd383f1b574b<br>binwalk out.txt <br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-194023.png" /></p><p>是个压缩包，改后缀尝试解压，然而不知道密码是啥。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-194522.png" /></p><p>联想到之前的奇怪HEX码，这有可能是压缩包密码的md5，在线搜索一个反查md5的网站并搜索。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-195222.png" /></p><p>再次尝试解压，是一张有点问题的jpg图片，扔给了队友处理，多番尝试下发现能用gimp打开。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-195804.png" /></p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>misc</tag>
      
      <tag>web</tag>
      
      <tag>writeup</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十五届ciscn捉虫题-基于挑战码的双向认证12</title>
    <link href="/2022/05/29/%E9%A2%98%E8%A7%A3/%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aciscn%E6%8D%89%E8%99%AB%E9%A2%98-%E5%9F%BA%E4%BA%8E%E6%8C%91%E6%88%98%E7%A0%81%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%8112/"/>
    <url>/2022/05/29/%E9%A2%98%E8%A7%A3/%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aciscn%E6%8D%89%E8%99%AB%E9%A2%98-%E5%9F%BA%E4%BA%8E%E6%8C%91%E6%88%98%E7%A0%81%E7%9A%84%E5%8F%8C%E5%90%91%E8%AE%A4%E8%AF%8112/</url>
    
    <content type="html"><![CDATA[<p>这原本这是一道密码学的题目，然而因为主办方的骚操作，变成了送分题目，先按照题目给的登陆ssh。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-190647.png" /></p><p>切换目录后发现了一个拥有权限的脚本，用 vim 打开并编辑。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-190915.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-190839.png" /></p><p>执行后就爆出了一堆数据，复制到编辑器中搜索 flag{ 作为关键字。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-191047.png" /></p><p>然后就拿到了flag。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
      <tag>writeup</tag>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>第十五届ciscn签到题题解</title>
    <link href="/2022/05/29/%E9%A2%98%E8%A7%A3/%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aciscn%E7%AD%BE%E5%88%B0%E9%A2%98%E9%A2%98%E8%A7%A3/"/>
    <url>/2022/05/29/%E9%A2%98%E8%A7%A3/%E7%AC%AC%E5%8D%81%E4%BA%94%E5%B1%8Aciscn%E7%AD%BE%E5%88%B0%E9%A2%98%E9%A2%98%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<p>根据题目描述，我们应该需要用“电报机”发送一段莫斯电码即可获得题解，但是手动输入实在太慢了，用 <strong>burp</strong> 抓下包看下。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-142853.png" /></p><p>貌似发送的电报的内容跟在 /send?msg= 后面，根据页面提示，将其内容替换为 s 试试。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-143308.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-143317.png" /></p><p>可以发现确实启动了电报机，我们的猜想是正确的，接下来只要构造出来需要发送的密文即可。</p><p>到这里思路就有点脱线了，怎么构造密文呢。。。题目上说可以关注公众号获取提示，那就搞一波。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-144246.jpeg" /></p><p>这提示给的很足，我们来看下。</p><p>首先是题目附带的密码本</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-144438.png" /></p><p>幸好题目很和善的还提供了纯数字形式，按照提示内容，这里只需要截取前 28 位即可，参考 <strong>Python</strong> 脚本如下。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">data = <span class="hljs-string">&quot;834685648904867613192673099158666557417553051522197326843480079548094074854764&quot;</span> \<br>       <span class="hljs-string">&quot;095047630000191153794197926361233736842472609828318082651439775355635663788013209&quot;</span> \<br>       <span class="hljs-string">&quot;25197425819452264702325443888920796415984073398294910727986125227947279765077202712&quot;</span> \<br>       <span class="hljs-string">&quot;6232829303975039778738498565689820634982168970069248569722529016689899816187765139477&quot;</span> \<br>       <span class="hljs-string">&quot;2472903500097506233876971292747251029017554573542354309201988176266150040395581176749534&quot;</span> \<br>       <span class="hljs-string">&quot;7399695531808357741572461296215239426044448640545307459932331102609691986455648348242316032&quot;</span> \<br>       <span class="hljs-string">&quot;47594332524713466289315&quot;</span><br><br>b = [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> data]<br>t1 = b[<span class="hljs-number">0</span>:<span class="hljs-number">28</span>]<br></code></pre></td></tr></table></figure><p>类似的，将提供的 7 个电码也转换为 <strong>Python</strong> 数组（已经去除了空格）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">s = <span class="hljs-string">&quot;1732251413440356045166710055&quot;</span><br>t2 = [<span class="hljs-built_in">int</span>(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> s]<br></code></pre></td></tr></table></figure><p>然后再将 t1 和 t2 数组中的每一位相加模 10 后拼接起来，最后输出</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">ans = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">28</span>):<br>    ans.append((t1[i] + t2[i]) % <span class="hljs-number">10</span>)<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> ans:<br>    <span class="hljs-built_in">print</span>(i, end=<span class="hljs-string">&quot;&quot;</span>)<br></code></pre></td></tr></table></figure><p>运行结果如下</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-145625.png" /></p><p>在 <strong>burp</strong> 中抓包并修改。</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-145821.png" /></p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/05/29/20220529-145837.png" /></p><p>然后就获得了 flag 。</p>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ctf</tag>
      
      <tag>web</tag>
      
      <tag>writeup</tag>
      
      <tag>crypto</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用rust搞个数据结构-链表3</title>
    <link href="/2022/04/02/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A83/"/>
    <url>/2022/04/02/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A83/</url>
    
    <content type="html"><![CDATA[<p>rust 里面的 for 循环实际上是个迭代器的语法糖。</p><p>比如常见的</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">100</span> &#123;<br>    todo!();<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们用 let 绑定一个变量到 1..100 上，利用标准库里的 type_name::<T>() 查看类型信息。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">type_of</span>&lt;T&gt;(_: &amp;T) <span class="hljs-punctuation">-&gt;</span> &amp;<span class="hljs-string">&#x27;static str&#123;</span><br><span class="hljs-string">    std::any::type_name::&lt;T&gt;()</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">fn main() &#123;</span><br><span class="hljs-string">    let i = 1..10;</span><br><span class="hljs-string">    println!(&quot;&#123;&#125;&quot;, type_of(&amp;i));</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>编译运行终端的输出为</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/04/24/20220424-165212.png" /></p><p>而标准库中这个泛型类型也实现了与迭代器相关的 trait</p><p><img src="https://cdn.jsdelivr.net/gh/OOJ2003/blog-img/data/2022/04/25/20220425-141409.png" /></p><p>在实际编译时 for 循环会被展开成常规的循环。</p><p>也正是因为 for 循环的这种特性，任何一个集合类型只要实现了迭代器相关的 trait ， 就可以遍历其所有子元素并进行操作。</p><p>首先我们来为我们的链表的 <strong>IntoIter</strong> 结构体实现 <strong>Iterator</strong> trait</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IntoIter</span>&lt;T&gt;(List&lt;T&gt;);<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; List&lt;T&gt; &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">into_iter</span>(<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> IntoIter&lt;T&gt; &#123;<br>        <span class="hljs-title function_ invoke__">IntoIter</span>(<span class="hljs-keyword">self</span>)<br>     &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Iterator</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">IntoIter</span>&lt;T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = T;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">next</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-keyword">Self</span>::Item&gt; &#123;<br>            <span class="hljs-keyword">self</span>.<span class="hljs-number">0</span>.<span class="hljs-title function_ invoke__">pop</span>()<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里我们首先实现了一个元组结构体 <strong>IntoIter</strong> ，这是一个泛型的结构体，其泛型参数与我们的链表保持一致，然后我们对其实现了 <strong>Iterator</strong> trait 。这个 trait 里面除了 <strong>next()</strong> 方法外还有一个<a href="https://doc.rust-lang.org/book/ch19-03-advanced-traits.html">关联类型</a> <strong>Item</strong> , 在这里我们将其定义为为我们链表的泛型参数。</p><p><strong>next()</strong> 方法的返回值即为使用 <strong>Option</strong> 包裹的关联类型。</p><p>实现了此 trait 即可使用 <strong>into_iter()</strong> 方法，注意此方法会消费所有权，绝大多数情况下这种并不常见。</p><p>接下来我们为我们的链表实现不获取所有权的 <strong>Iter</strong> 结构体和对应的 <strong>Iterator</strong> trait 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Iter</span>&lt;<span class="hljs-string">&#x27;a, T&gt; &#123;</span><br><span class="hljs-string">        next: Option&lt;&amp;&#x27;</span>a Node&lt;T&gt;&gt;,<br>    &#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-string">&#x27;a, T&gt; Iterator for Iter&lt;&#x27;</span>a, T&gt; &#123;<br><span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = &amp;<span class="hljs-string">&#x27;a T;</span><br><span class="hljs-string"></span><br><span class="hljs-string">fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="hljs-string">self.next.map(|node| &#123;</span><br><span class="hljs-string">self.next = node.after.as_deref();</span><br><span class="hljs-string">&amp;node.elem</span><br><span class="hljs-string">&#125;)</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>由于涉及到数据的借用，这里需要显示的标注出结构体的生命周期，这里满足生命周期省略原则，所以尽管 <strong>impl</strong> 块上标注了生命周期 <strong>'a</strong> ，但是 <strong>next()</strong> 方法并没有标出。</p><p>简单来说，在这里返回的借用的生命周期必然短于接受的借用，所以可以认为两者具有相同的生命周期约束 <strong>'a</strong>，其长短取决于返回借用实际存活的生命周期 。</p><p>类似的，返回拥有可变借用的 <strong>IterMut</strong> 结构体和 <strong>Iterator</strong> trait也是类似的设计。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">IterMut</span>&lt;<span class="hljs-string">&#x27;a, T&gt; &#123;</span><br><span class="hljs-string">    next: Option&lt;&amp;&#x27;</span>a <span class="hljs-keyword">mut</span> Node&lt;T&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span>&lt;<span class="hljs-string">&#x27;a, T&gt; Iterator for IterMut&lt;&#x27;</span>a, T&gt; &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Item</span> = &amp;<span class="hljs-string">&#x27;a mut T;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    fn next(&amp;mut self) -&gt; Option&lt;Self::Item&gt; &#123;</span><br><span class="hljs-string">        self.next.take().map(|node| &#123;</span><br><span class="hljs-string">            self.next = node.after.as_deref_mut();</span><br><span class="hljs-string">            &amp;mut node.elem</span><br><span class="hljs-string">        &#125;)</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>在剩下的两种迭代器的设计中，我们的代码用到了 <strong>as_deref()</strong> 和 <strong>as_deref_mut()</strong> 方法。</p><p>这两个方法的目的是将 <strong>Option<T></strong> 或其（可变）借用映射成用 <strong>Option</strong> 包装的包装物，以下为其对应的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_deref</span>(&amp;<span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;T::Target&gt;<br><span class="hljs-keyword">where</span><br>    T: Deref,<br></code></pre></td></tr></table></figure><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">const</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">as_deref_mut</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;&amp;<span class="hljs-keyword">mut</span> T::Target&gt;<br><span class="hljs-keyword">where</span><br>    T: DerefMut,<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用rust搞个数据结构--链表2</title>
    <link href="/2022/03/29/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A82/"/>
    <url>/2022/03/29/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A82/</url>
    
    <content type="html"><![CDATA[<p>上次实现的链表（链栈）无疑是十分简陋的，所以这次我们要实现一个更好更现代化的链表。</p><p>首先是项目的结构。上次项目的所有代码是写在 chain_table 这个 crate 的 main.rs 文件里，所以这次我们所有的代码都将放在一个新的 crate 里。</p><p>在 rust 里创建库是很简单的，只要在使用 cargo 时额外添加上 --lib 选项即可。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">cargo new --lib stack<br></code></pre></td></tr></table></figure><p>好的，我们现在移步到我们名为 stack 的 lib crate 里。</p><p>首先还是来看下我们要定义的的结构体。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> stack &#123;<br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>        elem: T,<br>        after: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;T&gt;&gt;<br>    &#125;<br><br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>        head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>引入泛型后又多了一重尖括号，这实在太难看了。。。</p><p>还好 rust 支持类型别名，所以我们可以稍微简化一下代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> stack &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Next</span>&lt;T&gt; = <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt; ;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>        elem: T,<br>        after: Next&lt;T&gt;<br>    &#125;<br>    <br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>        head: Next&lt;T&gt;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这样看起来就相对好些了。</p><p>因为我们实现的结构体的字段都是拥有所有权的类型，所以转换成泛型版本也是轻松无比，只要把原先的具体类型全部替换成泛型参数就可以了。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span>&lt;T&gt; Node&lt;T&gt; &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Node &#123;<br>                elem: elem,<br>                after: <span class="hljs-literal">None</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span>&lt;T&gt; List&lt;T&gt; &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            List &#123;<br>                head: <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>                    elem: elem,<br>                    after: <span class="hljs-literal">None</span>,<br>                &#125;)),<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(elem));<br>            new_node.after = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>            <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(new_node);<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;<br>            <span class="hljs-keyword">match</span> std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>) &#123;<br>                <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; &#123;<br>                    <span class="hljs-keyword">self</span>.head = x.after;<br>                    <span class="hljs-title function_ invoke__">Some</span>(x.elem)<br>                &#125;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>            <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-keyword">match</span> a &#123;<br>                    <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span>,<br>                    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">mut</span> x) =&gt; a = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> x.after, <span class="hljs-literal">None</span>),<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br></code></pre></td></tr></table></figure><p>另外就是，在标准库里，已经有很多 Option<T> 预先实现好的方法了，利用这些方法可以更进一步简化代码，比如 take() ，这是对 mem::replace() 的一个封装，下面是 take() 方法的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">take</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt;<br></code></pre></td></tr></table></figure><p>此外就是我们原先的代码中有模式匹配的部分只在匹配 Some(_) 时执行，而忽略了其他模式，此时我们可以用 if let 语法糖进一步简化我们的代码。</p><p>修改完成后完整代码如下。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-meta">#![allow(unused)]</span><br><span class="hljs-meta">#[cfg(test)]</span><br><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">it_works</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-variable">result</span> = <span class="hljs-number">2</span> + <span class="hljs-number">2</span>;<br>        <span class="hljs-built_in">assert_eq!</span>(result, <span class="hljs-number">4</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">mod</span> stack &#123;<br>    <span class="hljs-keyword">type</span> <span class="hljs-title class_">Next</span>&lt;T&gt; = <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt;;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>        elem: T,<br>        after: Next&lt;T&gt;,<br>    &#125;<br><br>    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>        head: Next&lt;T&gt;,<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span>&lt;T&gt; Node&lt;T&gt; &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            Node &#123;<br>                elem: elem,<br>                after: <span class="hljs-literal">None</span>,<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span>&lt;T&gt; List&lt;T&gt; &#123;<br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: T) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>            List &#123;<br>                head: <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>                    elem: elem,<br>                    after: <span class="hljs-literal">None</span>,<br>                &#125;)),<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: T) &#123;<br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(elem));<br>            new_node.after = <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">take</span>();<br>            <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(new_node);<br>        &#125;<br><br>        <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;T&gt; &#123;<br>            <span class="hljs-comment">// match std::mem::replace(&amp;mut self.head, None) &#123;</span><br>            <span class="hljs-comment">//     Some(x) =&gt; &#123;</span><br>            <span class="hljs-comment">//         self.head = x.after;</span><br>            <span class="hljs-comment">//         Some(x.elem)</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">//     None =&gt; None,</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">let</span> <span class="hljs-variable">Some</span>(x) = <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">take</span>() &#123;<br>                <span class="hljs-keyword">self</span>.head = x.after;<br>                <span class="hljs-title function_ invoke__">Some</span>(x.elem)<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-literal">None</span><br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">impl</span>&lt;T&gt; <span class="hljs-built_in">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>            <span class="hljs-comment">// let mut a = std::mem::replace(&amp;mut self.head, None);</span><br>            <span class="hljs-comment">// loop &#123;</span><br>            <span class="hljs-comment">//     match a &#123;</span><br>            <span class="hljs-comment">//         None =&gt; return,</span><br>            <span class="hljs-comment">//         Some(mut x) =&gt; a = std::mem::replace(&amp;mut x.after, None),</span><br>            <span class="hljs-comment">//     &#125;</span><br>            <span class="hljs-comment">// &#125;</span><br><br>            <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = <span class="hljs-keyword">self</span>.head.<span class="hljs-title function_ invoke__">take</span>();<br>            <span class="hljs-keyword">loop</span> &#123;<br>                <span class="hljs-keyword">match</span> a &#123;<br>                    <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">break</span>,<br>                    <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">mut</span> x) =&gt; a = x.after.<span class="hljs-title function_ invoke__">take</span>(),<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>OK， 我们的二进制库的大部分工作都完成了，现在来做写个单元测试来测试下我们的单向链表（链栈）。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">mod</span> tests &#123;<br>    <span class="hljs-keyword">use</span> crate::stack;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push_num</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_stack</span> = stack::List::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">1</span>);<br>        my_stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">2</span>);<br>        my_stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-number">3</span>);<br>        <span class="hljs-built_in">assert_eq!</span>(my_stack.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">3</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(my_stack.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">2</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(my_stack.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-number">1</span>));<br>        <span class="hljs-built_in">assert_eq!</span>(my_stack.<span class="hljs-title function_ invoke__">pop</span>(), <span class="hljs-literal">None</span>);<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">many_str</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_stack</span> = stack::List::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-string">&quot;hello&quot;</span>));<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10000</span> &#123;<br>            my_stack.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-type">String</span>::<span class="hljs-title function_ invoke__">from</span>(<span class="hljs-built_in">format!</span>(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, &amp;i)));<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">#[test]</span><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">many_nums</span>() &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">my_stack</span> = stack::List::<span class="hljs-title function_ invoke__">new</span>(<span class="hljs-number">0</span>);<br>        <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> <span class="hljs-number">1</span>..<span class="hljs-number">10000000</span> &#123;<br>            my_stack.<span class="hljs-title function_ invoke__">push</span>(i);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用 cargo 来 test 下看看。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cargo">cargo test                                                       <br>    Finished test [unoptimized + debuginfo] target(s) in 0.00s<br>     Running unittests (target/debug/deps/stack-25350f587195d617)<br><br>running 3 tests<br>test tests::push_num ... ok<br>test tests::many_str ... ok<br>test tests::many_nums ... ok<br><br>test result: ok. 3 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 1.80s<br><br>   Doc-tests stack<br><br>running 0 tests<br><br>test result: ok. 0 passed; 0 failed; 0 ignored; 0 measured; 0 filtered out; finished in 0.00s<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>用rust搞个数据结构--链表1</title>
    <link href="/2022/03/20/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A81/"/>
    <url>/2022/03/20/%E6%8A%80%E6%9C%AF/%E7%94%A8rust%E6%90%9E%E4%B8%AA%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A81/</url>
    
    <content type="html"><![CDATA[<p>最近一直在看 rust 相关的内容，之前也用 rust 写了面向对象的课设。但是当时并没有用到太多 rust 的特性来写。比如字符串为了规避生命周期的问题，直接采用了保留所有权的 String 类型等等。</p><p>所以为了弥补下上次的缺憾，也是为了加深学习，这次我要用rust来写一个简单的链表。</p><p>首先写几个结构体用于实现大致的内存布局。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span>&lt;T&gt; &#123;<br>    elem: T,<br>    next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span>&lt;T&gt; &#123;<br>    head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&lt;T&gt;&gt;&gt;,<br>&#125;<br></code></pre></td></tr></table></figure><p>注意这里的 next 字段类型是 Option&lt;Box&lt;Node<T>&gt;&gt;，Box 是 rust 中最常见的智能指针，用来将数据分配到堆内存上，而 Option 则是一个泛型枚举，用于表示可能不存在的数据。</p><p>标准库的定义就像这样</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> elem <span class="hljs-type">Option</span>&lt;T&gt; &#123; <span class="hljs-comment">//枚举是 sum type, 所以内容物只能是其定义中包含的类型之一</span><br>    <span class="hljs-title function_ invoke__">Some</span>(T), <br>    <span class="hljs-literal">None</span>, <span class="hljs-comment">//表示空类型</span><br>&#125;<br></code></pre></td></tr></table></figure><p>接下来来实现链表的初始化,为了简单考虑，接下来只会考虑实例化为储存 i32 类型的链表。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>    List &#123;<br>        head: <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>            elem: elem,<br>            next: <span class="hljs-literal">None</span>,<br>        &#125;)),<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后是最重要的部分，为链表实现添加和删除元素的方法。</p><p>单纯的链表可以有很多种增删元素的方式，比如头插、尾插或者指定位置插入，弹出元素也是类似的</p><p>push()和 pop()方法，先来看看 push()。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node&#123;<br>        elem: elem,<br>        next: <span class="hljs-keyword">self</span>.head,<br>    &#125;);<br>    <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(new_node);<br>&#125;<br></code></pre></td></tr></table></figure><p>理想很丰满，现实很骨感，虽然上面这段代码符合逻辑，但是这过不了编译，运行下 cargo check,来看看编译器在抱怨什么。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cargo">Checking chain_table v0.1.0 (/home/ooj2003/VSCodeProjects/rust/chain_table)<br>error[E0507]: cannot move out of `self.head` which is behind a mutable reference<br>  --&gt; src/main.rs:33:19<br>   |<br>33 |             next: self.head,<br>   |                   ^^^^^^^^^ move occurs because `self.head` has type `Option&lt;Box&lt;Node&lt;i32&gt;&gt;&gt;`, which does not implement the `Copy` trait<br>   |<br>help: consider borrowing the `Option`&#x27;s content<br>   |<br>33 |             next: self.head.as_ref(),<br>   |                            +++++++++<br><br>For more information about this error, try `rustc --explain E0507`.<br>error: could not compile `chain_table` due to previous error<br></code></pre></td></tr></table></figure><p>不太对劲，我们只是想在所有权的链条中插入一环，但是为什么编译器在抱怨我们没有给Option&lt;Box&lt;Node<i32>&gt;&gt; 实现 Copy trait？？？</p><p>这里就是 rust 与很多语言并不一致的地方，rust的自定义类型和内建的在堆上分配数据的类型在赋值时并不会发生拷贝（深克隆），而是默认采用了和c++11差不多的移动语义。由于rust的所有权模型还没有聪明到理解我们的行为，它在这种情形下只会笨笨的期望得到一个原链表的拷贝，所以这里我们采用一种偷天换日的方法来实现我们的想法。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: <span class="hljs-type">i32</span>) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(elem));<br>    new_node.next = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>    <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(new_node);<br>&#125;<br></code></pre></td></tr></table></figure><p>标准库中的 replace() 就是专为这种情形而生的。</p><p>以下下是标准库内 replace() 的函数签名。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">replace</span>&lt;T&gt;(dest: &amp;<span class="hljs-keyword">mut</span> T, src: T) <span class="hljs-punctuation">-&gt;</span> T<br></code></pre></td></tr></table></figure><p>大致意思是其接受一个可变引用，并用 src 去替换并返回其所有物。</p><p>在我们的 push() 方法的实现中，我们用 None 替换了头结点的 head字段，并将这个字段的内容转移给了我们新节点的next字段，最后将 new_node 包装在 Option<T> 枚举中并转移给头结点的head字段。</p><p>好的，现在 push() 方法能过编译了，接下来来处理 pop()方法</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">match</span> std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; &#123;<br>                <span class="hljs-keyword">self</span>.head = x.next;<br>                <span class="hljs-title function_ invoke__">Some</span>(x.elem)<br>            &#125;<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>如果头结点持有的链表为空，就直接返回 None, 不为空时相对复杂些。</p><p>用 H 代表头节点，则原先的所有权关系大致如图（箭头代表持有所有权） <span class="math display">\[self :H \rightarrow a \rightarrow b \rightarrow \dots\]</span> 现在我要取出 a 并返回，首先用 mem::replace() 函数将a的持有物置换为 None 并将置换所得绑定到一个新变量 new 上，此时所有权结构如下 <span class="math display">\[self: H, \quad new: a\rightarrow b \rightarrow\dots\]</span> 注意H的类型签名是 List<i32> ，a、b等小写字母（表示节点）的类型签名是 Node<i32>,</p><p>接下来用 Option 包装并返回 a 的 elem 字段内容物，并将 a 的 next 字段内容物的所有权移交给 H ，此时所有权结构如下。 <span class="math display">\[self: H \rightarrow b \rightarrow \dots\]</span> 此时 a 和 new 在完成操作后生命周期结束并自动调用析构函数被销毁。</p><p>其实到这里这个简单的链表其实已经做的差不多了，虽然文章标题是链表，但是完全就只是做了个链栈。。。</p><p>最后来收尾下整体的析构函数（不是节点的析构函数）。</p><p>一般来说， rust 中是不需要自己考虑编写析构函数的。rust 里面除了 unsafe 部分基本上全部的指针都是引用和智能指针，配合默认的移动语义，不特殊考虑的话基本上程序已经自动实现了 RAII ，但是这在处理链表的时候会遇到一些问题。</p><p>对于所有基本类型，rust 都已经实现了 Drop trait 即析构函数，自定义的结构体则会在生命周期结束时递归的为每个字段调用 drop 方法。当面对链表时，自动生成的析构函数则会递归的去找到表尾并销毁，然而是表尾前一个元素，然后再前一个，以此类推。</p><p>如果这个链表非常的长的话，不出预料的，程序会爆栈，所以我们要手动的为我们的链表实现 Drop trait 。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> a &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">mut</span> x) =&gt; a = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> x.next, <span class="hljs-literal">None</span>),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先用 replace() 函数将 self 的 head 字段用 None 替换，返回值绑定到变量 a 上，然后对 a 进行模式匹配，如果是 None 则表示链表为空或者已经匹配到表尾的 next 字段。如果不是， 则将匹配项的 next 字段重新绑定到 a 上， 注意这时原先 a 持有的内容物在这一操作后生命周期已经结束，编译器会自动为其调用 drop() 方法。这么一番操作下来，函数调用栈就不会被递归撑爆了。</p><p>以下为完整代码。</p><figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs rust"><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">Node</span> &#123;<br>    elem: <span class="hljs-type">i32</span>,<br>    next: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">pub</span> <span class="hljs-keyword">struct</span> <span class="hljs-title class_">List</span> &#123;<br>    head: <span class="hljs-type">Option</span>&lt;<span class="hljs-type">Box</span>&lt;Node&gt;&gt;,<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        List &#123;<br>            head: <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node &#123;<br>                elem: elem,<br>                next: <span class="hljs-literal">None</span>,<br>            &#125;)),<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">push</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>, elem: <span class="hljs-type">i32</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">new_node</span> = <span class="hljs-type">Box</span>::<span class="hljs-title function_ invoke__">new</span>(Node::<span class="hljs-title function_ invoke__">new</span>(elem));<br>        new_node.next = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>        <span class="hljs-keyword">self</span>.head = <span class="hljs-title function_ invoke__">Some</span>(new_node);<br>    &#125;<br><br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">pop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Option</span>&lt;<span class="hljs-type">i32</span>&gt; &#123;<br>        <span class="hljs-keyword">match</span> std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>) &#123;<br>            <span class="hljs-title function_ invoke__">Some</span>(x) =&gt; &#123;<br>                <span class="hljs-keyword">self</span>.head = x.next;<br>                <span class="hljs-title function_ invoke__">Some</span>(x.elem)<br>            &#125;<br>            <span class="hljs-literal">None</span> =&gt; <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Node</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">new</span>(elem: <span class="hljs-type">i32</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-keyword">Self</span> &#123;<br>        Node &#123;<br>            elem: elem,<br>            next: <span class="hljs-literal">None</span>,<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Drop</span> <span class="hljs-keyword">for</span> <span class="hljs-title class_">List</span> &#123;<br>    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">drop</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>) &#123;<br>        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">a</span> = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> <span class="hljs-keyword">self</span>.head, <span class="hljs-literal">None</span>);<br>        <span class="hljs-keyword">loop</span> &#123;<br>            <span class="hljs-keyword">match</span> a &#123;<br>                <span class="hljs-literal">None</span> =&gt; <span class="hljs-keyword">return</span>,<br>                <span class="hljs-title function_ invoke__">Some</span>(<span class="hljs-keyword">mut</span> x) =&gt; a = std::mem::<span class="hljs-title function_ invoke__">replace</span>(&amp;<span class="hljs-keyword">mut</span> x.next, <span class="hljs-literal">None</span>),<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>rust</category>
      
    </categories>
    
    
    <tags>
      
      <tag>rust</tag>
      
      <tag>数据结构</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>常微分方程学习笔记</title>
    <link href="/2022/03/12/%E7%AC%94%E8%AE%B0/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <url>/2022/03/12/%E7%AC%94%E8%AE%B0/%E5%B8%B8%E5%BE%AE%E5%88%86%E6%96%B9%E7%A8%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="写在所有之前">写在所有之前</h1><p>这篇是我之前复习常微分方程时写的小玩意儿，因为博客实在是太空了就拿上来充牌面了(๑•̀ㅂ•́)و✧</p><h1 id="基本概念">基本概念</h1><h2 id="方程的阶线性方程和非线性方程">方程的阶、线性方程和非线性方程</h2><h3 id="阶数">阶数</h3><p>如 <span class="math display">\[\frac{dy}{dx}=x^2+y^2\]</span></p><p>就为<strong>一阶方程</strong></p><blockquote><p>方程的阶数为其出现的最高阶导数的阶数</p></blockquote><h3 id="线性">线性</h3><p>但其不是一线性微分方程，因为其中包含有 <span class="math inline">\(y^2\)</span> 项</p><blockquote><p>线性微分方程： 若方程 <span class="math inline">\(F(x,y,\frac{dy}{dx},...,\frac{d^ny}{dx^n})=0\)</span> 中关于 <span class="math inline">\(y\)</span> 与其任意阶导数项皆为有理一次整式，则其为线性微分方程</p></blockquote><p>下为一个线性微分方程的例子 <span class="math display">\[\frac{d^2y}{dx^2}+\frac{dy}{dx}+y=3e^x\]</span></p><h3 id="齐次性">齐次性</h3><p>我们一般称 <span class="math inline">\(F(y,\dfrac{dy}{dx},\cdots,\dfrac{d^ny}{dx^n})=0\)</span> 这种类型的为齐次的</p><p>则 <span class="math inline">\(F(f(x),y,\dfrac{dy}{dx},\cdots,\dfrac{d^ny}{dx^n})=0,f(x)\ne0\)</span> 则为非齐次的</p><h2 id="解通解特解和初值条件">解、通解、特解和初值条件</h2><h3 id="通解">通解</h3><p>常微分方程的解中含有的独立任意常数的个数与方程的阶数相等</p><h3 id="特解">特解</h3><p>方程满足初值条件的解</p><h3 id="初值问题">初值问题</h3><p>诸如求解 <span class="math display">\[\left\{\begin{matrix}    \dfrac{dy}{dx}=f(x,y)\\\\    y|_{x=x_0}=y_0\end{matrix}\right.\]</span> 问题被称为一阶微分方程的初值问题，也被称为柯西问题</p><h2 id="线性相关与判据">线性相关与判据</h2><h3 id="函数的线性相关性">函数的线性相关性</h3><p>设 <span class="math inline">\(y_1(x),y_2(x),\cdots,y_n(x)\)</span> 为定义在区间 <span class="math inline">\(I\)</span> 内的 <span class="math inline">\(n\)</span> 个函数，如果存在 <span class="math inline">\(n\)</span> 个不全为 <span class="math inline">\(0\)</span> 的常数 <span class="math inline">\(C_1,C_2,...,C_n\)</span>，使得对 <span class="math inline">\(\forall x \in I\)</span> 都有 <span class="math display">\[C_1y_1(x)+C_2y_2(x)+\cdots+C_ny_n(x)=0\]</span> 则称这 <span class="math inline">\(n\)</span> 个函数在区间 <span class="math inline">\(I\)</span> 上是<strong>线性相关的</strong>，否则则称它们是<strong>线性无关的</strong></p><h3 id="线性相关无关的判定">线性相关（无关）的判定</h3><h4 id="朗斯基行列式">朗斯基行列式</h4><p>定义<strong>朗斯基行列式</strong> <span class="math display">\[W(x)=\left | \begin{matrix}  y_1(x)&amp; y_2(x)&amp;\cdots&amp;y_n(x)\\  y&#39;_1(x)&amp;y&#39;_2(x)&amp;\cdots&amp;y&#39;_n(x)\\  \vdots&amp;\vdots&amp;&amp;\vdots\\  y^{(k-1)}_1(x)&amp;y^{(k-1)}_2(x)&amp;\cdots&amp;y^{(k-1)}_n(x)\end{matrix} \right |\]</span></p><p><span class="math inline">\(n\)</span> 阶<strong>齐线性方程的</strong> <span class="math inline">\(n\)</span> 个解 <span class="math inline">\(y_1(x),y_2(x),...,y_n(x)\)</span> 在其定义区间 <span class="math inline">\(I\)</span> 上<strong>线性无关</strong>的<strong>充要</strong>条件是 <span class="math display">\[\exists x_0 \in I \Rightarrow W(x_0) \ne 0\]</span></p><h2 id="线性常微分方程组">线性常微分方程组</h2><h3 id="矩阵函数">矩阵函数</h3><p>对于一阶线性常微分方程组： <span class="math display">\[\left\{\begin{matrix}    \dfrac{dx_1}{dt}=a_{11}(t)x_1+a_{12}(t)x_2+\cdots+a_{1n}(t)x_n+f_1(t)\\\\    \dfrac{dx_2}{dt}=a_{21}(t)x_1+a_{22}(t)x_2+\cdots+a_{2n}(t)x_n+f_2(t)\\\\    .....................................................................\\\\    \dfrac{dx_n}{dt}=a_{n1}(t)x_1+a_{n2}(t)x_2+\cdots+a_{nn}(t)x_n+f_n(t)\end{matrix}\right.\tag{4-1}\]</span></p><p>其中 <span class="math inline">\(a_{ij}(t),f_i(t)\)</span> 均是关于 <span class="math inline">\(t\)</span> 的已知函数</p><p>记 <span class="math display">\[\pmb{A}(t)=\begin{bmatrix}    a_{11}(t)&amp;a_{12}(t)&amp;\cdots&amp;a_{1n}(t)\\    a_{21}(t)&amp;a_{22}(t)&amp;\cdots&amp;a_{2n}(t)\\    \vdots&amp;\vdots&amp; &amp;\vdots&amp;\\    a_{n1}(t)&amp;a_{n2}(t)&amp;\cdots&amp;a_{nn}(t)\\\end{bmatrix}\]</span></p><p>和 <span class="math display">\[\vec{f}(t)=\begin{bmatrix}    f_1(t)\\    f_2(t)\\    \vdots\\    f_n(t)\end{bmatrix}\]</span></p><p>和 <span class="math display">\[\vec{x}(t)=\begin{bmatrix}    f_1(t)\\    f_2(t)\\    \vdots\\    f_n(t)\end{bmatrix}\]</span></p><p>和 <span class="math display">\[\frac{d\vec{x}}{dt}=\begin{bmatrix}    \dfrac{dx_1}{dt}\\    \dfrac{dx_2}{dt}\\    \vdots\\    \dfrac{dx_n}{dt}\end{bmatrix}\]</span></p><p>则 <strong>（4-1）</strong> 可表示为 <span class="math display">\[\frac{d\vec{x}}{dt}=\pmb{A}(t)\vec{x}+\vec{f}(t)\]</span></p><h1 id="求解一阶常微分方程">求解一阶常微分方程</h1><h2 id="分离变量法">分离变量法</h2><p>分离变形后直接积分</p><h2 id="变量代换">变量代换</h2><h3 id="齐次化">齐次化</h3><p>为求解如 <span class="math display">\[\frac{dy}{dx}=f(x,y)\]</span> 的形式</p><p>如果有<span class="math inline">\(f(x,y)\equiv g(\frac{y}{x})\)</span>则做变量代换<span class="math inline">\(y=u x\)</span>可化原方程为 <span class="math display">\[\frac{du}{dx}=\frac{g(u)-u}{x}\]</span> 此时分离后可直接积分</p><h3 id="二元一次分式">二元一次分式</h3><p>为求解方程 <span class="math display">\[\frac{dy}{dx}=\frac{a_1x+b_1y+c_1}{a_2x+b_2y+c_2}\]</span> 且其满足 <span class="math display">\[\left\{\begin{matrix}   a_1^2+a_2^2\ne 0\\   b_1^2+b_2^2\ne 0\\   a_1^2+b_2^2\ne 0\\   a_2^2+b_1^2\ne 0\end{matrix}\right.\]</span> &gt; 当上述限制条件不存在时，其是容易分离后直接积分的</p><p>我们分三种情况讨论</p><h4 id="当-c_1c_20">(1)当 <span class="math inline">\(c_1=c_2=0\)</span></h4><p>容易得 <span class="math display">\[\frac{dy}{dx}=\frac{a_1+b_1\frac{y}{x}}{a_2+b_2\frac{y}{x}}\]</span> 只需用齐次化的方式处理即可求解</p><h4 id="当-c_12c_22ne-0leftbeginmatrixa_1b_1a_2b_2endmatrixright0">(2)当 <span class="math inline">\(c_1^2+c_2^2\ne 0,\left|\begin{matrix}a_1&amp;b_1\\a_2&amp;b_2\end{matrix}\right|=0\)</span></h4><p>此时有 <span class="math inline">\(a_1b_2=a_2b_1\)</span></p><h5 id="a_2b_2ne-0">Ⅰ <span class="math inline">\(a_2b_2\ne 0\)</span></h5><p>令 <span class="math display">\[\frac{a_1}{a_2}=\frac{b_1}{b_2}=k\]</span> 则有 <span class="math display">\[\frac{dy}{dx}=\frac{k(a_2x+b_2y)+c_1}{a_2x+b_2y+c_2}\]</span> 做代换<span class="math display">\[u=a_2x+b_2y\]</span></p><p>上式化为 <span class="math display">\[\frac{du}{dx}=a_2+b_2\frac{dy}{dx}=a_2+b_2\frac{ku+c_1}{u+c_2}\]</span> 而此式是容易分离后积分的</p><h5 id="a_2b_20">Ⅱ <span class="math inline">\(a_2b_2=0\)</span></h5><p>此时有 <span class="math inline">\(a_2=b_2=0\)</span></p><p>即 <span class="math display">\[\frac{dy}{dx}=\frac{a_1x+b_1y+c_1}{c_2}\]</span> 令 <span class="math display">\[u=a_1x+b_1y\]</span> 则 <span class="math display">\[\frac{du}{dx}=a_1+\frac{b_1}{c_2}(u+c_1)\]</span></p><h4 id="当-c_12c_22ne-0leftbeginmatrixa_1b_1a_2b_2endmatrixrightne0">(3) 当 <span class="math inline">\(c_1^2+c_2^2\ne 0,\left|\begin{matrix}a_1&amp;b_1\\a_2&amp;b_2\end{matrix}\right|\ne0\)</span></h4><p>由<span class="math inline">\(\left|\begin{matrix}a_1&amp;b_1\\a_2&amp;b_2\end{matrix}\right|\ne0\)</span>知 <span class="math display">\[\left\{\begin{matrix}a_1x+b_1y+c_1=0\\a_2x+b_2y+c_2=0\end{matrix}\right.\]</span> 是有解的</p><p>其解 <span class="math display">\[\begin{bmatrix} x\\y\end{bmatrix}=\begin{bmatrix}x_0\\y_0\end{bmatrix}\]</span> 考虑平移变换 <span class="math display">\[\left\{\begin{matrix}x=X+x_0\\y=Y+y_0\end{matrix}\right.\]</span> 代入化简得 <span class="math display">\[\frac{dY}{dX}=\frac{a_1X+b_1Y}{a_2X+b_2Y}\]</span> 此式是为齐次化后容易求解的</p><h3 id="类轮换对称式随便取的名">类轮换对称式（随便取的名）</h3><p>方程 <span class="math display">\[yf(xy)dx+xg(xy)dy=0\]</span> 做代换 <span class="math display">\[u=xy\]</span> 即 <span class="math display">\[du=ydx+xdy\]</span> 带入得 <span class="math display">\[yf(u)dx+g(u)(du-ydx)=0\]</span></p><p><span class="math display">\[g(u)du=y[g(u)-f(u)]dx=\frac{u}{x}[g(u)-f(u)]dx\]</span> 整理得 <span class="math display">\[\frac{g(u)}{u[g(u)-f(u)]}du=\frac{dx}{x}\]</span> 此式是可直接积分求解的</p><h2 id="常数变易法">常数变易法</h2><h3 id="通解公式">通解公式</h3><p>一阶线性方程可以写成 <span class="math display">\[\frac{dy}{dx}=p(x)y+q(x)\]</span> 并称 <span class="math display">\[\frac{dy}{dx}=p(x)y\]</span> 为上式对应的齐线性方程</p><p>齐线性方程是易解的，其通解为 <span class="math display">\[y=Ce^{\int p(x)dx}\]</span> 猜测非齐线性方程通解具有类似形式，即 <span class="math display">\[y=C(x)e^{\int p(x)dx}\]</span> 带入得 <span class="math display">\[\frac{dC(x)}{dx}=q(x)e^{-\int p(x)dx}\]</span> 故 <span class="math display">\[C(x)=\int q(x)e^{-\int p(x)dx}dx+\tilde{C}\]</span> 回代得 <span class="math display">\[y=e^{\int p(x)dx}[\int q(x)e^{-\int p(x)dx}dx+C]\]</span></p><h3 id="伯努利方程">伯努利方程</h3><p>称 <span class="math display">\[\frac{dy}{dx}+p(x)y=q(x)y^n\]</span> 且满足<span class="math inline">\((n\ne 0,1)\)</span>的方程为伯努利方程</p><p>容易观察到到 <span class="math inline">\(y=0\)</span> 为一解，当 <span class="math inline">\(y\ne 0\)</span> 时，两边同乘 <span class="math inline">\(y^{-n}\)</span> 得 <span class="math display">\[y^{-n}\frac{dy}{dx}+p(x)y^{1-n}=q(x)\]</span> 令 <span class="math display">\[y^{1-n}=z\]</span> 则有 <span class="math display">\[\frac{dz}{dx}=(1-n)y^{-n}\frac{dy}{dx}\]</span> 回代得 <span class="math display">\[\frac{dz}{dx}+(1-n)p(x)z=(1-n)q(x)\]</span> 这是一一阶非齐线性常微分方程，可通过通解公式求解</p><h2 id="凑全微分法和积分因子法">凑全微分法和积分因子法</h2><h3 id="恰当方程">恰当方程</h3><p>若对 <span class="math display">\[M(x,y)dx+N(x,y)dy=0\]</span> 恰好有 <span class="math display">\[du(x,y)\equiv M(x,y)dx+N(x,y)dy\]</span> 则称其为<strong>恰当方程</strong>或<strong>全微分方程</strong></p><p>则其通积分 <span class="math display">\[u(x,y)= C\]</span> 即所求通解</p><h4 id="恰当方程的验证">恰当方程的验证</h4><p>若对 <span class="math display">\[M(x,y)dx+N(x,y)dy=0\]</span> 有 <span class="math display">\[\dfrac{\partial M}{\partial y}=\dfrac{\partial N}{\partial x}\]</span> 则其为恰当方程，否则不是恰当方程</p><h4 id="uxy-的求解"><span class="math inline">\(u(x,y)\)</span> 的求解</h4><p>显然 <span class="math display">\[\left\{\begin{matrix}\dfrac{\partial u}{\partial x}=M(x,y)\\\\\dfrac{\partial u}{\partial y}=N(x,y)\end{matrix}\right.\]</span> 对其积分得 <span class="math display">\[u(x,y)=\int M(x,y)dx+\varphi(y)\]</span> 则有 <span class="math display">\[\frac{\partial u}{\partial y}=\frac{\partial}{\partial y}\int M(x,y)dx+{\varphi}&#39;(y)\]</span> 故 <span class="math display">\[{\varphi}&#39;(y)=N(x,y)-\frac{\partial}{\partial y}\int M(x,y)dx\]</span> 积分后回代即可求出 <span class="math inline">\(u(x,y)\)</span></p><p>若考虑 <span class="math display">\[u(x,y)=\int N(x,y)dy+\phi(x)\]</span> 其过程也是类似的</p><h3 id="凑全微分法">凑全微分法</h3><p>这个靠感觉，给个例题感受下</p><p>例1.求解方程 <span class="math inline">\((3x^2+6xy^2)dx+(6x^2y+4y^3)dy=0\)</span></p><p>解:</p><p>显然其为恰当方程，整理得 <span class="math display">\[d(x^3)+d(y^4)+d(3x^2y^2)=0\]</span> 即 <span class="math display">\[d(x^3+y^4+3x^2y^2)=0\]</span> 通积分得 <span class="math display">\[x^3+y^4+3x^2y^2=C\]</span></p><h4 id="常用的全微分公式">常用的全微分公式</h4><p><span class="math display">\[d(xy)=ydx+xdy\]</span></p><p><span class="math display">\[d(x^2siny)=2xsinydx+x^2cosydy\]</span></p><p><span class="math display">\[d(\frac{x}{y})=\frac{ydx-xdy}{y^2}\]</span></p><p><span class="math display">\[d(\frac{y}{x})=\frac{xdy-ydx}{x^2}\]</span></p><p><span class="math display">\[d(ln|\frac{x}{y}|)=\frac{ydx-xdy}{y^2}\]</span></p><p><span class="math display">\[d(arctan\frac{x}{y})=\frac{ydx-xdy}{x^2+y^2}\]</span></p><h3 id="积分因子法">积分因子法</h3><p>若对 <span class="math display">\[M(x,y)dx+N(x,y)dy=0\]</span> 有 <span class="math display">\[\frac{\partial M}{\partial y}-\frac{\partial N}{\partial x}\ne 0\]</span> 假定存在 <span class="math inline">\(\mu(x,y)\)</span> 使得 <span class="math display">\[\mu(Mdx+Ndy)\equiv du(x,y)\]</span> 则称其为原方程的一积分因子</p><h4 id="积分因子的求法">积分因子的求法</h4><h5 id="公式法">公式法</h5><p>对于 <span class="math display">\[M(x,y)dx+N(x,y)dy=0\]</span> 有 <span class="math display">\[\left\{\begin{matrix}    \varphi (x)\equiv \dfrac{\dfrac{\partial M}{\partial y}-\dfrac{\partial N}{\partial x}}{N}\\\\    \psi (y)\equiv \dfrac{\dfrac{\partial N}{\partial x}-\dfrac{\partial M}{\partial y}}{M}\end{matrix}\right.\]</span> 则 <span class="math display">\[\left\{\begin{matrix}    \mu(x)=e^{\int\varphi(x)dx}\\    \mu(y)=e^{\int\psi(y)dy}\end{matrix}\right.\]</span></p><h5 id="逆推法不记公式看个人喜好">逆推法（不记公式，看个人喜好）</h5><p>对于 <span class="math display">\[M(x,y)dx+N(x,y)dy=0\]</span> 假定存在 <span class="math inline">\(\mu(x)\)</span>使得 <span class="math display">\[\frac{\partial(\mu(x)M)}{y}-\frac{\partial(\mu(x)N)}{\partial x}=0\]</span> 求解上述方程即可求出 <span class="math inline">\(\mu(x)\)</span> ，同理也可求出 <span class="math inline">\(\mu(y)\)</span></p><p>由于实际题目中可能 <span class="math inline">\(\mu(x)\)</span> 是易求的，也可能 <span class="math inline">\(\mu(y)\)</span> 是易求的，运气差的话要尝试2次</p><h2 id="引入参数法">引入参数法</h2><h3 id="可解出未知函数或未知量的方程">可解出未知函数（或未知量）的方程</h3><h4 id="yfxfracpartial-ypartial-x"><span class="math inline">\(y=f(x,\frac{\partial y}{\partial x})\)</span></h4><p>引入参数 <span class="math inline">\(\dfrac{\partial y}{\partial x}=p\)</span> ,则有 <span class="math display">\[p=\frac{\partial f}{\partial x}+\frac{\partial f}{\partial p}\frac{dp}{dx}\]</span> 这是可解的，其其通解满足以下形式 <span class="math display">\[p=\varphi(x,C) \longrightarrowy=f(x.\varphi(x,C))\]</span></p><p><span class="math display">\[x=\psi(p,C) \longrightarrow\left\{\begin{matrix}    x=\psi(p,C)\\    y=f(\psi(p,c),p)\end{matrix}\right.\]</span></p><p><span class="math display">\[\Phi(x,p,C)=0 \longrightarrow\left\{\begin{matrix}    \Phi(x,p,C)=0\\    y=f(x,p)\end{matrix}\right.\]</span></p><h4 id="xfyfracdydx"><span class="math inline">\(x=f(y,\frac{dy}{dx})\)</span></h4><p>引入参数 <span class="math inline">\(\frac{dy}{dx}=p\)</span> ,则原方程变为 <span class="math display">\[x=f(y,p)\]</span> 对 <span class="math inline">\(y\)</span> 求导有 <span class="math inline">\(\frac{dx}{dy}=\frac{1}{p}\)</span> 故 <span class="math display">\[\frac{1}{p}=\frac{\partial f}{\partial y}+\frac{\partial f}{\partial p}\frac{dp}{dy}\]</span></p><h3 id="不显含未知函数或自变量的方程">不显含未知函数（或自变量）的方程</h3><h4 id="不显含-y-的方程">不显含 <span class="math inline">\(y\)</span> 的方程</h4><p><span class="math display">\[F(x,y&#39;)=0\]</span> 令 <span class="math inline">\(y&#39;=p\)</span> 则方程变为 <span class="math display">\[F(x,p)=0\]</span> 其存在一参数形式 <span class="math display">\[x=\varphi(t),p=\psi(t)\]</span> 则有 <span class="math display">\[dy=pdx=\psi(t)\varphi&#39;(t)dt\]</span> 综上，有其参数形式通解 <span class="math display">\[\left\{\begin{matrix}    x=\varphi(t)\\    y=\int\psi(t)\varphi&#39;(t)dt+C\end{matrix}\right.\]</span></p><h4 id="不显含-x-的方程">不显含 <span class="math inline">\(x\)</span> 的方程</h4><p><span class="math display">\[F(y,y&#39;)=0\]</span> 令 <span class="math inline">\(y&#39;=p\)</span> ，方程化为 <span class="math display">\[F(y,p)=0\]</span> 其存在一参数形式 <span class="math display">\[y=\varphi(t),p=\psi(t)\]</span> 则有 <span class="math display">\[dx=\frac{dy}{p}=\frac{\varphi&#39;(t)}{\psi(t)}dt\]</span> 综上，有其参数形式通解 <span class="math display">\[\left\{\begin{matrix}    x=\int\dfrac{\varphi&#39;(t)}{\psi(t)}dt+C\\    y=\varphi(t)\end{matrix}\right.\]</span></p><h1 id="求解高阶常微分方程">求解高阶常微分方程</h1><h2 id="非常系数微分方程">非常系数微分方程</h2><h3 id="齐线性微分方程">齐线性微分方程</h3><h4 id="齐线性微分方程解的结构">齐线性微分方程解的结构</h4><p>如果 <span class="math inline">\(y_1(x),y_2(x),\cdots,y_n(x)\)</span> 是齐线性方程在定义区间 <span class="math inline">\(I\)</span> 的 <span class="math inline">\(n\)</span> 个线性无关的解则方程的通解为 <span class="math display">\[y=C_1y_1(x)+C_2y_2(x)+\cdots+C_ny_n(x)\]</span> 其中 <span class="math inline">\(C_1,C_2,\cdots,C_n\)</span> 为任意常数，并称 <span class="math inline">\(y_1(x),y_2(x),\cdots,y_n(x)\)</span> 为原方程的基本解组</p><h4 id="观察法求解二阶齐线性微分方程">观察法求解二阶齐线性微分方程</h4><h5 id="可能的简单特解">可能的简单特解</h5><p>对于方程 <span class="math display">\[y&#39;&#39;+p_1(x)y&#39;+p_2(x)y=0\]</span> (1).当 <span class="math inline">\(p_1(x)+xp_2(x)=0\)</span> 时， <span class="math inline">\(y=x\)</span> 为其一解 (2).当 <span class="math inline">\(1+p_1(x)+p_2(x)=0\)</span> 时 <span class="math inline">\(y=e^x\)</span> 为其一解 (3).当 <span class="math inline">\(1-p_1(x)+p_2(x)=0\)</span> 时， <span class="math inline">\(y=e^{-x}\)</span> 为其一解 (4).当 <span class="math inline">\(\lambda^2+\lambda p_1(x)+p_2(x)=0\)</span> 时， <span class="math inline">\(y=e^{\lambda x}\)</span> 为其一解</p><h5 id="代入法求另一解">代入法求另一解</h5><p>设 <span class="math inline">\(y_1\)</span> 为 <span class="math inline">\(y&#39;&#39;+p_1(x)y&#39;+p_2(x)y=0\)</span> 的一个非零特解 则可设 <span class="math inline">\(y_2=C(x)y_1\)</span> 为其另一与 <span class="math inline">\(y_1\)</span> 线性无关的解 代入原方程化简得 <span class="math display">\[(2y_1&#39;+p_1(x)y1)C&#39;(x)+y_1C&#39;&#39;(x)=0\]</span> 分离变量后积分得 <span class="math display">\[C(x)=\int\dfrac{e^{-\int p_1(x)dx}}{y_1^2}dx\]</span> 带回得 <span class="math display">\[y_2=y_1\int\dfrac{e^{-\int p_1(x)dx}}{y_1^2}dx\]</span></p><h3 id="非齐线性微分方程">非齐线性微分方程</h3><h4 id="非齐线性微分方程解的结构">非齐线性微分方程解的结构</h4><p>设 <span class="math inline">\(y^*\)</span> 为 <span class="math inline">\(y^{(n)}+p_1(x)y^{(n-1)}+\cdots+p_{n-1}(x)y&#39;+p_n(x)y=f(x)\)</span> 的一特解， <span class="math inline">\(\bar{y}=C_1y_1(x)+C_2y_2(x)+\cdots+C_ny_n(x)\)</span> 为原方程对应的齐线性方程的通解，则 <span class="math inline">\(y=\bar{y}+y^*\)</span> 为其通解</p><h4 id="特解的求解">特解的求解</h4><p>设 <span class="math display">\[y=C_1y_1(x)+C_2y_2(x)+\cdots+C_ny_n(x) \tag{3-10}\]</span> 为 <span class="math display">\[y^{(n)}+p_1(x)y^{(n-1)}+\cdots+p_{n-1}(x)y&#39;+p_n(x)y=0\tag{3-2}\]</span> 的通解</p><p>常数变易法得 <span class="math display">\[y=C_1(x)y_1(x)+C_2(x)y_2(x)+\cdots+C_n(x)y_n(x) \tag{3-11}\]</span> 对 <span class="math inline">\(x\)</span> 求导得 <span class="math display">\[y&#39;=C_1(x)y&#39;_1(x)+C_2(x)y&#39;_2(x)+\cdots+C_n(x)y&#39;_n(x)+\\y_1(x)C_1&#39;(x)+y_2(x)C_2&#39;(x)+\cdots+y_n(x)C&#39;_x(x)\]</span> 为求解 <span class="math inline">\(C_i(x)\)</span> ，需要 <span class="math inline">\(n-1\)</span> 个限制条件 令 <span class="math display">\[y_1(x)C_1&#39;(x)+y_2(x)C_2&#39;(x)+\cdots+y_n(x)C&#39;_n(x)=0 \tag{3-11-1}\]</span> 得 <span class="math display">\[y&#39;=C_1(x)y&#39;_1(x)+C_2(x)y&#39;_2(x)+\cdots+C_n(x)y&#39;_n(x) \tag{3-12-1}\]</span> 同理有条件 <span class="math display">\[y_1&#39;(x)C_1&#39;(x)+y_2&#39;(x)C_2&#39;(x)+\cdots+y_n&#39;(x)C&#39;_n(x)=0 \tag{3-11-2}\]</span> 和表达式 <span class="math display">\[y&#39;&#39;=C_1(x)y&#39;&#39;_1(x)+C_2(x)y&#39;&#39;_2(x)+\cdots+C_n(x)y&#39;&#39;_n(x) \tag{3-12-2}\]</span> 重复上述操作有第 <span class="math inline">\(n-1\)</span> 个条件 <span class="math display">\[y_1(x)^{(n-2)}C_1&#39;(x)+y_2(x)^{(n-2)}C_2&#39;(x)+\cdots+y_n(x)^{(n-2)}C&#39;_n(x)=0 \\ \tag{3-11-(n-1)}\]</span> 与表达式 <span class="math display">\[y^{(n-1)}=C_1(x)y^{(n-1)}_1(x)+C_2(x)y^{(n-1)}_2(x)+\cdots+C_n(x)y^{(n-1)}_n(x) \\ \tag{3-12-(n-1)}\]</span> 最终对式 <strong>(3-12-(n-1))</strong> 再求导得 <span class="math display">\[y^{(n)}=C_1(x)y^{(n)}_1(x)+C_2(x)y^{(n)}_2(x)+\cdots+C_n(x)y^{(n)}_n(x)+\\y_1^{n-1}(x)C_1&#39;(x)+y_2^{n-1}(x)C_2&#39;(x)+\cdots+y_n^{n-1}(x)C_n&#39;(x)+\]</span> 回代得 <span class="math display">\[y_1(x)^{(n-1)}C_1&#39;(x)+y_2(x)^{(n-1)}C_2&#39;(x)+\cdots+y_n(x)^{(n-1)}C&#39;_n(x)=f(x) \\ \tag{3-11-n}\]</span> 所以 <strong>(3-11-1),(3-11-2),...,(3-11-n),</strong> 构成了一个线性方程组，且其系数矩阵的行列式即为原非齐线性方程对应的齐线性方程的一基础解组的朗斯基行列式，其恒不等于0，所以该线性方程组有唯一解</p><p>设求得 <span class="math display">\[C_i&#39;(x)=\varphi&#39;_i(x)\]</span> 则有 <span class="math display">\[C_i(x)=\int\varphi&#39;_i(x)dx+k_i\]</span> 回代得 <span class="math display">\[y=\sum_{i=1}^{n}{[\int\varphi&#39;_i(x)dx+k_i]y_i(x)}\]</span> 取 <span class="math inline">\(k_i=0\)</span> ，则得解 <span class="math display">\[y=\sum_{i=1}^{n}{y_i(x)\int\varphi&#39;_i(x)dx}\]</span></p><h2 id="常系数微分方程">常系数微分方程</h2><h3 id="常系数齐线性微分方程">常系数齐线性微分方程</h3><h4 id="特征根法">特征根法</h4><h5 id="二阶常系数齐线性方程的特征根法">二阶常系数齐线性方程的特征根法</h5><p>二阶常系数齐线性方程的一般形式为 <span class="math display">\[y&#39;&#39;+p_1y&#39;+p_2y=0 \tag{3-14}\]</span> 其中 <span class="math inline">\(p_1,p_2\)</span> 是常数，称 <span class="math inline">\(r^2+p_1r+p_2=0\)</span> 为该方程的特征方程， <span class="math inline">\(r_1,r_2\)</span> 为其两根称为特征根，接下来对特征根分别讨论</p><h6 id="r_1-ne-r_2r_1-in-rr_2-in-r">（1） <span class="math inline">\(r_1 \ne r_2,r_1 \in R,r_2 \in R\)</span></h6><p>两个线性无关的特解分别为 <span class="math display">\[y_1=e^{r_1x},y_2=e^{r_2x}\]</span> 通解为 <span class="math display">\[y=C_1e^{r_1x}+C_2e^{r_2x}\]</span></p><h6 id="r_1r_2-dfracp_12r_1-in-rr_2-in-r">（2） <span class="math inline">\(r_1=r_2=-\dfrac{p_1}{2},r_1 \in R,r_2 \in R\)</span></h6><p>特解 <span class="math display">\[y_1=e^{rx},y_2=xe^{rx}\]</span> 通解 <span class="math display">\[y=C_1e^{rx}+C_2xe^{rx}=(C_1+C_2x)e^{rx}\]</span></p><h6 id="r_12alphapm-ibetabetane0r_12in-c">（3） <span class="math inline">\(r_{1,2}=\alpha\pm i\beta,\beta\ne0,r_{1,2}\in C\)</span></h6><p>特解 <span class="math display">\[y_1=e^{\alpha x}cos\beta x,y_2=e^{\alpha x}sin\beta x,\]</span> 通解 <span class="math display">\[y=e^{\alpha x}(C_1cos\beta x+C_2sin\beta x)\]</span></p><h5 id="高阶常系数齐线性方程的解">高阶常系数齐线性方程的解</h5><table><thead><tr class="header"><th>特征方程的根</th><th>微分方程对应的线性无关解</th></tr></thead><tbody><tr class="odd"><td>(Ⅰ)单实根 <span class="math inline">\(r\)</span></td><td>对应一个解: <span class="math inline">\(y_1=e^{rx}\)</span></td></tr><tr class="even"><td>(Ⅱ)一对单虚根 $r_{1,2}=i$</td><td>对应两个线性无关解: <span class="math inline">\(y_1=e^{\alpha x}cos\beta x,y_2=e^{\alpha x}sin\beta x\)</span></td></tr><tr class="odd"><td>(Ⅲ) <span class="math inline">\(k\)</span> 重实根 <span class="math inline">\(r\)</span></td><td>对应 <span class="math inline">\(k\)</span> 个线性无关解: <span class="math inline">\(y_1=e^{rx},y_2=xe^{rx},\cdots,y_k=x^{k-1}e^{rx}\)</span></td></tr><tr class="even"><td>(Ⅳ)一对 <span class="math inline">\(k\)</span> 重虚根 <span class="math inline">\(r_{1,2}=\alpha\pm i\beta\)</span></td><td>对应 <span class="math inline">\(2k\)</span> 个线性无关解: <span class="math inline">\(y_1=e^{\alpha x}cos\beta x,y_2=e^{\alpha x}sin\beta x;y_3=xe^{\alpha x}cos\beta x,y_4=xe^{\alpha x}sin\beta x;\cdots \cdots;y_{2k-1}=x^{k-1}e^{\alpha x}cos\beta x,y_{2k}=x^{k-1}e^{\alpha x}sin\beta x\)</span></td></tr></tbody></table><h3 id="常系数非齐线性微分方程">常系数非齐线性微分方程</h3><h4 id="待定系数法求解二阶常系数非齐线性微分方程的特解">待定系数法求解二阶常系数非齐线性微分方程的特解</h4><p>二阶常系数非齐微分方程的一般形式为 <span class="math display">\[y&#39;&#39;+p_1y&#39;+p_2y=f(x)\tag{3-17}\]</span></p><h5 id="类型ⅰ-fxelambda-xqx-lambda-为常数-p_mx-为-m-次多项式">类型Ⅰ <span class="math inline">\(f(x)=e^{\lambda x}Q(x)\)</span> ，<span class="math inline">\(\lambda\)</span> 为常数， <span class="math inline">\(p_m(x)\)</span> 为 <span class="math inline">\(m\)</span> 次多项式</h5><p>则 <strong>（3-17）</strong> 有如下形式的特解 <span class="math display">\[y^*=x^ke^{\lambda x}Q_m(x)\tag{3-18}\]</span> 其中 <span class="math inline">\(Q_m(x)\)</span> 为 <span class="math inline">\(m\)</span> 次多项式， <span class="math inline">\(k\)</span> 为 <span class="math inline">\(\lambda\)</span> 作为 <strong>（3-17）</strong> 的特征方程的根的重数（如果 <span class="math inline">\(\lambda\)</span> 不是特征根，则取 <span class="math inline">\(k=0\)</span> ） 为求 <span class="math inline">\(Q_m(x)\)</span> ，将 <strong>（3-18）</strong> 回代 <strong>（3-17）</strong> 后展开并比较系数即可</p><h5 id="类型ⅱ-fxealpha-xp_lxcosbeta-xq_nxsinbeta-x-alphabeta-为常数-p_lxq_nx-分别为-ln-次多项式">类型Ⅱ <span class="math inline">\(f(x)=e^{\alpha x}[P_l(x)cos\beta x+Q_n(x)sin\beta x]\)</span> , <span class="math inline">\(\alpha,\beta\)</span> 为常数， <span class="math inline">\(P_l(x),Q_n(x)\)</span> 分别为 <span class="math inline">\(l,n\)</span> 次多项式</h5><p>此时，方程 <strong>（3-17）</strong> 具有如下形式的特解 <span class="math display">\[y^*=x^ke^{\alpha x}[R_m^{(1)}(x)cos\beta x+R_m^{(2)}(x)sin\beta x]\]</span> 其中 <span class="math inline">\(\alpha\pm i\beta\)</span> 不是特征方程的根时， <span class="math inline">\(k=0\)</span> ；当 <span class="math inline">\(\alpha\pm i\beta\)</span> 是特征方程的根时， <span class="math inline">\(k=1\)</span> ； <span class="math inline">\(R_m^{(1)}(x),R_m^{(2)}(x)\)</span> 是 <span class="math inline">\(m\)</span> 次多项式， <span class="math inline">\(m=max\{l,n\}\)</span></p><h2 id="可降阶的常微分方程">可降阶的常微分方程</h2><h3 id="ynfx-型的方程"><span class="math inline">\(y^{(n)}=f(x)\)</span> 型的方程</h3><p>两边同时积分</p><h3 id="fxykyk1cdotsyn0-型的方程且满足-1le-kle-n"><span class="math inline">\(F(x,y^{(k)},y^{(k+1)},\cdots,y^{(n)})=0\)</span> 型的方程，且满足 <span class="math inline">\((1\le k\le n)\)</span></h3><p>对于方程 <span class="math display">\[F(x,y^{(k)},y^{(k+1)},\cdots,y^{(n)})=0\tag{3-29}\]</span> 作变量代换 <span class="math inline">\(y^{(k)}=p\)</span> ，则有 <span class="math display">\[F(x,p&#39;,p&#39;&#39;,\cdots,p^{(n-k)})=0\tag{3-30}\]</span> 如果 <strong>（3-30）</strong> 有通解 <span class="math display">\[y^{(k)}=p=\varphi(x,C_1,C_2,\cdots,C_{n-k})\]</span> 两边同时积分可求解</p><h3 id="fyyycdotsyn0-型的方程"><span class="math inline">\(F(y,y&#39;,y&#39;&#39;,\cdots,y^{(n)})=0\)</span> 型的方程</h3><p>对于方程 <span class="math display">\[F(y,y&#39;,y&#39;&#39;,\cdots,y^{(n)})=0\]</span> 作变量代换 <span class="math inline">\(y&#39;=p\)</span> 则有 <span class="math display">\[\frac{dy}{dx}=p\\\frac{d^2x}{dy^2}=\frac{dp}{dx}=\frac{dp}{dy}\cdot\frac{dy}{dx}=p\frac{dp}{dy}\\\frac{d^3p}{dy^3}=\frac{d}{dx}(p\frac{dp}{dy})=p\frac{d}{dy}(p\frac{dp}{dy})=p^2\frac{d^2p}{dy^2}+p(\frac{dp}{dy})^2\\\cdots \cdots \cdots \cdots\]</span> 逐步回代后可将方程降阶为易求的形式</p><h3 id="fxyycdotsynfracddxvarphixyycdotsyn-10-型的方程"><span class="math inline">\(F(x,y,y&#39;,\cdots,y^{(n)})=\frac{d}{dx}\varPhi(x,y,y&#39;,\cdots,y^{(n-1)})=0\)</span> 型的方程</h3><p>先求解 <span class="math display">\[\varPhi(x,y,y&#39;,\cdots,y^{(n-1)})=C\]</span></p><p>再继续考虑求解原方程</p><h1 id="求解常系数一阶常微分方程组">求解常系数一阶常微分方程组</h1><h2 id="常系数一阶齐线性常微分方程组">常系数一阶齐线性常微分方程组</h2><h3 id="常系数齐线性常微分方程组通解的结构">常系数齐线性常微分方程组通解的结构</h3><h4 id="向量函数的线性无关与朗斯基行列式">向量函数的线性无关与朗斯基行列式</h4><p>设 <span class="math inline">\(\vec{\varphi}_1(t),\vec{\varphi}_2(t),\cdots,\vec{\varphi}_m(t)\)</span> 为定义在 <span class="math inline">\(I\)</span> 上的 <span class="math inline">\(m\)</span> 个 <span class="math inline">\(n\)</span> 维向量函数，如果存在 <span class="math inline">\(m\)</span> 个不全为 <span class="math inline">\(0\)</span> 的常数 <span class="math inline">\(C_1,C_2,\cdots,C_m\)</span> 使得 <span class="math display">\[\forall t \in I \Rrightarrow C_1\vec{\varphi}_1(t)+C_2\vec{\varphi}_2(t)+\cdots+C_m\vec{\varphi}_m(t)\equiv0\]</span> 则称其为在区间 <span class="math inline">\(I\)</span> 上是<strong>线性相关的</strong>，否则则称为是<strong>线性无关的</strong></p><p>设由 <span class="math inline">\(\vec{\varphi}_1(t),\vec{\varphi}_2(t),\cdots,\vec{\varphi}_m(t)\)</span> 构成的<strong>朗斯基行列式</strong> <span class="math display">\[W(x)=\begin{vmatrix}    {\varphi}_{11}(t)&amp;{\varphi}_{12}(t)&amp;\cdots&amp;{\varphi}_{1n}(t)\\    {\varphi}_{21}(t)&amp;{\varphi}_{22}(t)&amp;\cdots&amp;{\varphi}_{2n}(t)\\    \vdots&amp;\vdots&amp; &amp;\vdots\\    {\varphi}_{n1}(t)&amp;{\varphi}_{n2}(t)&amp;\cdots&amp;{\varphi}_{nn}(t)\end{vmatrix}\]</span></p><p>则有 <span class="math display">\[\vec{\varphi}_1(t),\vec{\varphi}_2(t),\cdots,\vec{\varphi}_m(t)在区间I上线性相关\Rightarrow \forall t \in I,W(t)\equiv 0\]</span></p><h4 id="基本解组与基解矩阵">基本解组与基解矩阵</h4><p>对于齐线性微分方程组 <span class="math display">\[\frac{d\vec{x}}{dt}=\pmb{A}(t)\vec{x} \tag{4-6}\]</span></p><p>如果 <span class="math inline">\(\vec{\varphi}_1(t),\vec{\varphi}_2(t),\cdots,\vec{\varphi}_n(t)\)</span> 是 <strong>（4-6）</strong> 在区间 <span class="math inline">\(I\)</span> 上的 <span class="math inline">\(n\)</span> 个线性无关的解，那么称这组向量函数为原方程组的<strong>基本解组</strong></p><p>记一 <span class="math inline">\(n\times n\)</span> 矩阵 <span class="math inline">\(\pmb{\varPhi}(t)\)</span> 的每一列都是 <strong>（4-6）</strong> 的一个解 <span class="math inline">\(\varphi_i(t)\)</span></p><p>即 <span class="math display">\[\pmb{\varPhi}(t)=(\vec{\varphi}_1(t),\vec{\varphi}_2(t),\cdots,\vec{\varphi}_n(t))\]</span></p><p>所以 <span class="math display">\[\pmb{\varPhi}(t)=\begin{vmatrix}    {\varphi}_{11}(t)&amp;{\varphi}_{12}(t)&amp;\cdots&amp;{\varphi}_{1n}(t)\\    {\varphi}_{21}(t)&amp;{\varphi}_{22}(t)&amp;\cdots&amp;{\varphi}_{2n}(t)\\    \vdots&amp;\vdots&amp; &amp;\vdots\\    {\varphi}_{n1}(t)&amp;{\varphi}_{n2}(t)&amp;\cdots&amp;{\varphi}_{nn}(t)\end{vmatrix}\]</span></p><p>则称 <span class="math display">\[\pmb{\varPhi}(t)\]</span></p><p>为式 <strong>（4-6）</strong> 的一个解矩阵，若满足 <span class="math inline">\(\forall t \in I,det\pmb{\varPhi}(t)\ne 0\)</span> 则称其为 <strong>（4-6）</strong> 的一个基解矩阵</p><h3 id="待定系数法法求解常系数一阶齐线性微分方程组">待定系数法法求解常系数一阶齐线性微分方程组</h3><h4 id="系数矩阵的特征根都为单根">系数矩阵的特征根都为单根</h4><p>若系数矩阵有 <span class="math inline">\(n\)</span> 个不同的特征根 <span class="math inline">\(\lambda_1,\lambda_2,\cdots,\lambda_n\)</span> 且 <span class="math inline">\(\vec{T}_i\)</span> 为 <span class="math inline">\(\lambda_i\)</span> 所对应的特征向量则其基解矩阵 <span class="math display">\[\pmb{\varPhi}(t)=(\vec{T}_1(t)e^{\lambda_1 t},\vec{T}_2(t)e^{\lambda_2 t},\cdots,\vec{T}_n(t)e^{\lambda_n t})\]</span></p><h4 id="系数矩阵的特征根存在重根">系数矩阵的特征根存在重根</h4><p>设系数矩阵有 <span class="math inline">\(m\)</span> 个不相同的特征根 <span class="math inline">\(\lambda_i,(i\le m)\)</span> 对应的重数为 <span class="math inline">\(k_i\)</span> 且有 <span class="math inline">\(\sum_{i=1}^{m}k_i=n\)</span> ，则对于特征根 <span class="math inline">\(\lambda_i\)</span> ，方程组有 <span class="math inline">\(k_i\)</span> 个如下形式的线性无关的解 <span class="math display">\[\begin{bmatrix}    \begin{bmatrix}        a_{10}\\        a_{20}\\        \vdots\\        a_{n0}    \end{bmatrix}+    \begin{bmatrix}        a_{11}\\        a_{21}\\        \vdots\\        a_{n1}    \end{bmatrix}t+    \cdots+    \begin{bmatrix}        a_{1,k_i-1}\\        a_{2,k_i-1}\\        \vdots\\        a_{n,k_i-1}    \end{bmatrix}t^{k_i-1}\end{bmatrix}e^{\lambda_it}\]</span></p><h4 id="系数矩阵的特征根存在虚根">系数矩阵的特征根存在虚根</h4><p>若存在虚数解 <span class="math inline">\(\vec{z}(t)=\vec{\varphi}(t)+i\vec{\psi}(t)\)</span> 则其实部和虚部都是原方程的解</p><h2 id="常系数一阶非齐线性微分方程组的求解">常系数一阶非齐线性微分方程组的求解</h2><p>对于 <span class="math display">\[\frac{d\vec{x}}{dt}=\pmb{A}(t)\vec{x}+\vec{f}(t)\]</span> 采用待定系数法求解其特解 <span class="math inline">\(\varphi^*(t)\)</span></p><h3 id="vecftp_1tp_2tcdotsp_nttealpha-t-其中-p_it-是关于-t-的多项式"><span class="math inline">\(\vec{f}(t)=(P_1(t),P_2(t),\cdots,P_n(t))^Te^{\alpha t}\)</span> 其中 <span class="math inline">\(P_i(t)\)</span> 是关于 <span class="math inline">\(t\)</span> 的多项式</h3><p>此时存在如下形式的特解 <span class="math display">\[\varphi^*(t)=(Q_1(t),Q_2(t),\cdots,Q_m(t))^Te^{\alpha t}\]</span> 其中 <span class="math inline">\(Q_i(t)\)</span> 是关于 <span class="math inline">\(t\)</span> 的待定多项式，它们的次数都是 <span class="math inline">\(m+l\)</span> 次 ， <span class="math inline">\(m\)</span> 为 <span class="math inline">\(P_i(t)\)</span> 的最高次数；当 <span class="math inline">\(\alpha\)</span> 为特征根时， <span class="math inline">\(l\)</span> 为其重数，否则 <span class="math inline">\(l=0\)</span> ，将上述形式回代到原方程后展开并比较系数即可解得其一特解</p><h3 id="vecftp_1tcosbeta-ttildep_1sinbeta-tcdotsp_ntcosbeta-ttildep_n-sinbeta-ttealpha-t-其中-p_ittildep_it-均是关于-t-的多项式"><span class="math inline">\(\vec{f}(t)=(P_1(t)cos\beta t,\tilde{P}_1sin\beta t,\cdots,P_n(t)cos\beta t,\tilde{P}_n sin\beta t)^Te^{\alpha t}\)</span> 其中 <span class="math inline">\(P_i(t),\tilde{P}_i(t)\)</span> 均是关于 <span class="math inline">\(t\)</span> 的多项式</h3><p>此时存在如下形式的特解 <span class="math display">\[\varphi^*(t)=(Q_1(t)cos\beta t,\tilde{Q}_1sin\beta t,\cdots,Q_n(t)cos\beta t,\tilde{Q}_n sin\beta t)^Te^{\alpha t}\]</span></p><p>其中 <span class="math inline">\(Q_i(t),\tilde{Q}_i(t)\)</span> 是关于 <span class="math inline">\(t\)</span> 的待定实系数多项式，它们的次数都是 <span class="math inline">\(m+l\)</span> 次 ， <span class="math inline">\(m\)</span> 为 <span class="math inline">\(P_i(t),\tilde{P}_i(t)\)</span> 的最高次数；当 <span class="math inline">\(\alpha+i\beta\)</span> 为特征根时， <span class="math inline">\(l\)</span> 为其重数，否则 <span class="math inline">\(l=0\)</span> ，将上述形式回代到原方程后展开并比较系数即可解得其一特解</p><h1 id="附录">附录</h1><h2 id="鸣谢">鸣谢</h2><p>非常感谢 [隐私原因，已删除]大佬 允许我使用他的思维导图作为模板创作了这篇小文 ψ(｀∇´)ψ</p><h2 id="版本历史记录">版本历史记录</h2><p>2021/7/2 发布 v1.0.0</p><p>2021/7/2 本地存档，未发布 v1.0.1 增加了许可协议的详细描述，修正了一些小错误</p><p>2021/7/3 发布 v1.1.0 完成所有ToDo任务</p>]]></content>
    
    
    <categories>
      
      <category>课程笔记</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数学</tag>
      
      <tag>学习</tag>
      
      <tag>常微分方程</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
